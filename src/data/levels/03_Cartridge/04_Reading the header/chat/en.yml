---
main:
  run: |
    if (m.$end) $.goTo("exercise");
  messages:
  - hey
  - look at your ğŸ“  ~/docs~ directory!
  responses:
  - what's there? [exercise]

exercise:
  run: |
    set((m) => m.$end = true);
  messages:
  - I've sent you some documentation ğŸ¤“
  - check out ğŸ“„  ~/docs/iNEEES.en.md~
  - it's a document describing the iNEEES format
  - you can inspect it with the `open` command, or by <clicking> on the file path
  - I want you to read it and tell me if you understand
  responses:
  - ğŸ¤”  I think I understand [understand]
  - (*) what's a mapper? ğŸ—œï¸ [mapper]
  - (*) what's mirroring? ğŸš½ [mirroring]
  - (*) please define PRG-ROM, CHR-ROM, PRG-RAM and CHR-RAM ğŸ [memories]
  - (*) padding? ğŸ§¸ [padding]
  - (*) what the hell is a "nybble"? ğŸ¦´ [nybble]

mapper:
  messages:
  - it's kind of an "expansion chip" that every game has
  - they help the console read larger programs and graphics chunks
  - and they allow games to perform more complex operations like changing mirroring on the fly
  - more on that later! ğŸ”œ
  responses:
  - ...exercise

mirroring:
  messages:
  - mirroring affects what's shown past the right and bottom edges of the screen
  - depending on the mirroring type, the PPU will use different memory sections to draw backgrounds ğŸ¨
  - it doesn't matter too much right now
  responses:
  - ...exercise

memories:
  messages:
  - ok, let's try...
  - "ğŸ¤–  PRG-ROM: read-only memory that contains the program"
  - "ğŸ‘¾  CHR-ROM: read-only memory that contains the graphics"
  - "ğŸ‘¾  CHR-RAM: writable memory to store graphics at runtime"
  - "ğŸ”‹  PRG-RAM: (optional) writable memory to store game progress"
  - each game uses either CHR-ROM or CHR-RAM
  - if it uses CHR-RAM, the iNEEES file will not contain its last CHR-ROM section
  responses:
  - ...exercise

padding:
  messages:
  - just zeroes, a part of the file which you can ignore
  responses:
  - ...exercise

nybble:
  messages:
  - a nybble is half a byte
  - so "lower nybble" means the first 4 bits (```raw 0000```~1011~)
  - and "upper nybble" means the last 4 bits (~1011~```raw 0000```)
  responses:
  - ...exercise

understand:
  messages:
  - awesome ğŸ’ª
  - the first 16 bytes of the file represent the ğŸ—£ï¸  header
  - |-
    ğŸ“š  let's add a `header` property to the ğŸ’¾  `Cartridge` class, with the following form:
    ```javascript {
      prgRomPages: 2, // (obtain this from byte 4)
      chrRomPages: 1, // (obtain this from byte 5)
      usesChrRam: false, // (true if chrRomPages === 0)
      has512BytePadding: false, // (obtain this from <Flags 6>)
      hasPrgRam: false, // (obtain this from <Flags 6>)
      mirroringId: "VERTICAL", // (obtain this from <Flags 6>)
      mapperId: 4 // (obtain this from <Flags 6> and <Flags 7>)
    }```
  responses:
  - I need a bit of help ğŸ“ [bits]

bits:
  messages:
  - if you don't know how to operate with bits, you can use my library ğŸ“–
  - it's in ğŸ“„  ~/lib/byte.js~, just import it as another module and use it
  - the methods you'd want to use are `getFlag(...)`, `highNybbleOf(...)`, `lowNybbleOf(...)`, and `buildU8(...)`
  responses:
  - how can I use the module? [import]

import:
  messages:
  - |-
    just import it like this:
      ```javascript import byte from "/lib/byte";```
  - ğŸ’¡ you can test the library by using the `repl` command
  - an interactive JS prompt! ğŸ¤¯
  - |-
    try running these lines of code:
    ```javascript
    // (0x means <hexadecimal> and 0b means <binary>)
    byte.getFlag(0b00000100, 2) // bit 2 is 1 => true
    byte.getFlag(0b00000100, 4) // bit 4 is 0 => false
    byte.highNybbleOf(0b00110100) // high nybble is 0b0011 => 3
    byte.lowNybbleOf(0b00110100) // low nybble is 0b0100 => 4
    byte.buildU8(0b0011, 0b0100) // 0b00110100 => 52```
  responses: []
