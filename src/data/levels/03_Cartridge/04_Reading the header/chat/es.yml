---
main:
  run: |
    if (m.$end) $.goTo("exercise");
  messages:
  - ey
  - Â¡mira tu directorio ğŸ“  ~/docs~!
  responses:
  - Â¿quÃ© hay ahÃ­? [exercise]

exercise:
  run: |
    set((m) => m.$end = true);
  messages:
  - te enviÃ© algo de documentaciÃ³n ğŸ¤“
  - revisa ğŸ“„  ~/docs/iNEEES.es.md~
  - es un documento que describe el formato iNEEES
  - puedes inspeccionarlo con el comando `open`, o <clickeando> en la ruta al archivo
  - quiero que lo veas y me digas si entiendes
  responses:
  - ğŸ¤”  creo que entiendo [understand]
  - (*) Â¿quÃ© es un mapper? ğŸ—œï¸ [mapper]
  - (*) Â¿quÃ© es mirroring? ğŸš½ [mirroring]
  - (*) por favor, define PRG-ROM, CHR-ROM, PRG-RAM y CHR-RAM ğŸ [memories]
  - (*) Â¿relleno? ğŸ§¸ [padding]
  - (*) Â¿quÃ© demonios es un "nybble"? ğŸ¦´ [nybble]

mapper:
  messages:
  - es como un "chip de expansiÃ³n" que todo juego tiene
  - ayudan a la consola a leer programas y datos grÃ¡ficos mÃ¡s grandes
  - y permiten que los juegos realicen operaciones mÃ¡s complejas como modificar el mirroring sobre la marcha
  - Â¡mÃ¡s sobre eso luego! ğŸ”œ
  responses:
  - ...exercise

mirroring:
  messages:
  - el mirroring define quÃ© se va a mostrar pasado el borde derecho e inferior de la pantalla
  - dependiendo del tipo de mirroring, la PPU usarÃ¡ diferentes secciones de memoria para dibujar fondos ğŸ¨
  - no importa demasiado por ahora
  responses:
  - ...exercise

memories:
  messages:
  - ok, intentarÃ©...
  - "ğŸ¤–  PRG-ROM: memoria de solo lectura que contiene el programa"
  - "ğŸ‘¾  CHR-ROM: memoria de solo lectura que contiene los grÃ¡ficos"
  - "ğŸ‘¾  CHR-RAM: memoria escribible para poner grÃ¡ficos en tiempo de ejecuciÃ³n"
  - "ğŸ”‹  PRG-RAM: (opcional) memoria escribible para almacenar el progreso del juego"
  - cada juego usa CHR-ROM o CHR-RAM
  - si usa CHR-RAM, el archivo iNEEES no contendrÃ¡ su Ãºltima secciÃ³n de CHR-ROM
  responses:
  - ...exercise

padding:
  messages:
  - solo ceros, una parte del archivo que puedes ignorar
  responses:
  - ...exercise

nybble:
  messages:
  - un nybble es medio byte
  - por lo que "nybble inferior" significa los primeros 4 bits (```raw 0000```~1011~)
  - y "nybble superior" significa los Ãºltimos 4 bits (~1011~```raw 0000```)
  responses:
  - ...exercise

understand:
  messages:
  - excelente ğŸ’ª
  - los primeros 16 bytes del archivo representan la ğŸ—£ï¸  cabecera
  - |-
    ğŸ“š  agreguemos una propiedad `header` a la clase ğŸ’¾  `Cartridge`, con la siguiente forma:
    ```javascript {
      prgRomPages: 2, // (obtener esto del byte 4)
      chrRomPages: 1, // (obtener esto del byte 5)
      usesChrRam: false, // (true si chrRomPages === 0)
      has512BytePadding: false, // (obtener esto de <Flags 6>)
      hasPrgRam: false, // (obtener esto de <Flags 6>)
      mirroringId: "VERTICAL", // (obtener esto de <Flags 6>)
      mapperId: 4 // (obtener esto de <Flags 6> y <Flags 7>)
    }```
  responses:
  - necesito un poco de ayuda ğŸ“ [bits]

bits:
  messages:
  - si no sabes cÃ³mo operar con bits, puedes usar mi biblioteca ğŸ“–
  - estÃ¡ en ğŸ“„  ~/lib/byte.js~, solo impÃ³rtala como otro mÃ³dulo mÃ¡s y Ãºsala
  - los mÃ©todos que querrÃ¡s usar son `getFlag(...)`, `highNybbleOf(...)`, `lowNybbleOf(...)` y `buildU8(...)`
  responses:
  - Â¿cÃ³mo puedo usar el mÃ³dulo? [import]

import:
  messages:
  - |-
    solo impÃ³rtalo asÃ­:
      ```javascript import byte from "/lib/byte";```
  - ğŸ’¡ puedes probar la biblioteca con el comando `repl`
  - Â¡una consola JS interactiva! ğŸ¤¯
  - |-
    intenta ejecutar estas lÃ­neas de cÃ³digo:
    ```javascript
    // (0x implica <hexadecimal> y 0b implica <binario>)
    byte.getFlag(0b00000100, 2) // el bit 2 es 1 => true
    byte.getFlag(0b00000100, 4) // el bit 4 es 0 => false
    byte.highNybbleOf(0b00110100) // el high nybble es 0b0011 => 3
    byte.lowNybbleOf(0b00110100) // el low nybble es 0b0100 => 4
    byte.buildU8(0b0011, 0b0100) // 0b00110100 => 52```
  responses: []
