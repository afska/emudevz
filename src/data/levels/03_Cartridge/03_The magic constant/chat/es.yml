---
main:
  messages:
  - los juegos se suelen preservar en formato digital con <archivos de juego> (tambiÃ©n llamados <ROMs>)
  - estos contienen ğŸ¤–  <cÃ³digo>, ğŸ‘¾  <grÃ¡ficos> y una ğŸ—£ï¸  <cabecera> que identifica el hardware
  responses:
  - son los famosos archivos <*.neees>, Â¿no? [neeesfiles]

neeesfiles:
  messages:
  - correcto, el formato se llama iNEEES, y deberÃ­as empezar leyendo su <cabecera>
  - "los primeros 4 bytes de un archivo de juego siempre contienen lo siguiente:"
  - $4E $45 $53 $1A
  - esa es <la constante mÃ¡gica> âœ¨
  - deberÃ­as buscar esos bytes para verificar si una ROM es vÃ¡lida o no
  responses:
  - Â¿quÃ© quieres que haga? [exercise]

exercise:
  run: |
    set((m) => m.$end = true);
  messages:
  - ğŸ“š  agrega un constructor a la clase ğŸ’¾  `Cartridge` que reciba los bytes de la ROM
  - ğŸ“š  guÃ¡rdalos en una propiedad llamada `bytes`
  - ğŸ“š  si la constante mÃ¡gica no coincide con $4E $45 $53 $1A, tira un error con el mensaje "Invalid ROM."
  responses:
  - (*) Â¿cÃ³mo puedo agregar un constructor? ğŸ˜³ [constructor]
  - (*) necesito ayuda verificando los bytes ğŸ¥º [help]
  - (*) ayÃºdame a tirar un error ğŸ¤” [errors]

constructor:
  messages:
  - |-
    luego de agregar un constructor y guardar los bytes, tu cÃ³digo deberÃ­a verse asÃ­:
      ```javascript
      export default class Cartridge {
        constructor(bytes) {
          this.bytes = bytes;
          // Â¡verifica los bytes aquÃ­!
        }
      }
      ```
  responses:
  - ...exercise

help:
  messages:
  - vas a recibir un `Uint8Array`, Â¡que funciona similar a los arrays comunes!
  - por lo que ```javascript bytes[0]``` representa el primer byte, ```javascript bytes[1]``` el segundo, y asÃ­
  - recuerda que puedes expresar notaciÃ³n hexadecimal con el prefijo ~0x~, p. ej. `0x4e`
  responses:
  - ...exercise

errors:
  messages:
  - |-
    para tirar errores, usa:
      ```javascript throw new Error(\"un mensaje\");```
  responses:
  - ...exercise
