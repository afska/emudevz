---
main:
  run: |
    if (m.$end) $.goTo("exercise");
  messages:
  - los juegos se suelen preservar en formato digital con archivos de juego (tambiÃ©n llamados ROMs) ğŸ‘¾
  - estos contienen cÃ³digo, grÃ¡ficos y una cabecera que identifica el hardware
  responses:
  - son los famosos archivos *.neees, Â¿no? [neeesfiles]

neeesfiles:
  messages:
  - correcto, el formato se llama <iNEEES>, y deberÃ­as empezar leyendo su cabecera
  - "los primeros 4 bytes de un archivo de juego siempre contienen lo siguiente:"
  - $4E $45 $53 $1A
  - que representa la secuencia ASCII del nombre de la consola ("NEEES"), pero con una sola "E"
  - esa es <la constante mÃ¡gica> âœ¨
  - deberÃ­as buscar esos bytes para verificar si una ROM es vÃ¡lida o no
  responses:
  - Â¿quÃ© quieres que haga? [exercise]

exercise:
  run: |
    set((m) => m.$end = true);
  messages:
  - ğŸ“š  agrega un constructor a la clase `Cartridge` que reciba los bytes de la ROM
  - guÃ¡rdalos en una propiedad llamada `bytes`
  - si la constante mÃ¡gica no coincide con $4E $45 $53 $1A, tira un error con el mensaje "Invalid ROM."
  responses:
  - Â¿cÃ³mo puedo agregar un constructor? ğŸ˜³ [constructor]
  - necesito ayuda verificando los bytes ğŸ¥º [help]
  - ayÃºdame a tirar un error ğŸ¤” [errors]

constructor:
  messages:
  - |-
    luego de agregar un constructor y guardar los bytes, tu cÃ³digo deberÃ­a verse asÃ­:
      ```javascript
      export default class Cartridge {
        constructor(bytes) {
          this.bytes = bytes;
          // Â¡verifica los bytes aquÃ­!
        }
      }
      ```
  responses: []

help:
  messages:
  - vas a recibir un `Uint8Array`, Â¡que funciona similar a los arrays comunes!
  - por lo que ```javascript bytes[0]``` representa el primer byte, ```javascript bytes[1]``` el segundo, y asÃ­
  - recuerda que puedes expresar notaciÃ³n hexadecimal con el prefijo ~0x~, p. ej. ~0x4e~
  responses: []

errors:
  messages:
  - "para tirar errores, usa:\n  ```javascript throw new Error(\"un mensaje\");```"
  responses: []
