---
main:
  messages:
  - we preserve games in digital format with <game files> (also called <ROMs>)
  - these contain ğŸ¤–  <code>, ğŸ‘¾  <graphics>, and a ğŸ—£ï¸  <header> that identifies the hardware
  responses:
  - they're the famous <*.neees> files, right? [neeesfiles]

neeesfiles:
  messages:
  - right, the format is called iNEEES, and you should start by reading its <header>
  - "the first 4 bytes of a game file always contain the following:"
  - $4E $45 $53 $1A
  - that's <the magic constant> âœ¨
  - you should look for these bytes to check whether a ROM is valid or not
  responses:
  - what do you want me to do? [exercise]

exercise:
  messages:
  - ğŸ“š  add a constructor to the ğŸ’¾  `Cartridge` class receiving the ROM bytes
  - ğŸ“š  save them in a property called `bytes`
  - ğŸ“š  if the magic constant doesn't match $4E $45 $53 $1A, throw an error with the "Invalid ROM." message
  responses:
  - (*) how can I add a constructor? ğŸ˜³ [constructor]
  - (*) I need help checking the bytes ğŸ¥º [help]
  - (*) help me throw an error ğŸ¤” [errors]

constructor:
  messages:
  - |-
    after adding a constructor and saving the bytes, your code should look like this:
      ```javascript
      export default class Cartridge {
        constructor(bytes) {
          this.bytes = bytes;
          // check the bytes here!
        }
      }
      ```
  responses:
  - ...exercise

help:
  messages:
  - you'll receive a `Uint8Array`, which works similar to regular arrays!
  - so ```javascript bytes[0]``` represents the first byte, ```javascript bytes[1]``` the second one, and so on
  - remember that you can express hexadecimal notation with the ~0x~ prefix, i.e. `0x4e`
  responses:
  - ...exercise

errors:
  messages:
  - |-
    to throw errors, use:
      ```javascript throw new Error(\"a message\");```
  responses:
  - ...exercise
