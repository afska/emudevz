---
main:
  run: |
    set((m) => {
      m.chat.winOnEnd = true;
      m.chat.stopBlock = locales.get("not_now");
      m.$canRun = false;
    });
  messages:
  - dÃ©jame presentarte al editor de cÃ³digo
  - bueno, aÃºn no es <editor> ğŸ˜…
  - solo un visor
  - tiene un ejemplo de un programa bÃ¡sico de NEEES
  responses:
  - (*) el visor no me asusta, lo que sÃ­ lo hace son los nÃºmeros raros de abajo [debugger]
  - Â¿quÃ© lenguaje es Ã©ste? ğŸ˜® [language]

debugger:
  messages:
  - Â¿el depurador de CPU?
  - nah, no te preocupes
  - Â¡voy a explicar todo!
  responses:
  - ...main

language:
  messages:
  - Â¡es lenguaje ensamblador!
  - el nivel mÃ¡s bajo de abstracciÃ³n de las computadoras ğŸ’»
  - se traduce directo a los bytes que son ejecutados por la CPU
  responses:
  - entonces, despuÃ©s de compilar, Â¿se va a convertir en un conjunto raro de bytes? [machinecode]

machinecode:
  messages:
  - correcto
  - de hecho, estÃ¡s viendo el cÃ³digo compilado ahora mismo
  - fÃ­jate en el Visor de Memoria en la parte de abajo de la pantalla
  - el cÃ³digo empieza desde la direcciÃ³n de memoria $4020
  - si posas el cursor de tu mouse sobre una de estas direcciones, mostrarÃ¡ dÃ³nde empieza cada instrucciÃ³n
  responses:
  - (*) Â¿quÃ© es una direcciÃ³n de memoria? [address]
  - Â¿quÃ© son los otros nÃºmeros? ğŸ‘€ [otherthings]

address:
  messages:
  - un nÃºmero de 2 bytes que representa una ubicaciÃ³n dentro de la memoria ğŸ
  - puede ir de 0 ($0000) a 65535 ($FFFF)
  responses:
  - pero dijiste que la NEEES solo tenÃ­a 2KiB (2048 bytes) de memoria ğŸ˜• [butyousaid]
  - ...machinecode

butyousaid:
  messages:
  - eso es cierto
  - pero la CPU puede <ver> hasta 64KiB
  - asÃ­ que los primeros dos kilobytes son RAM de verdad
  - y el resto se usa para interactuar con el hardware ğŸ’»
  - eso no importa mucho en este capÃ­tulo
  - estamos simulando una RAM de 64KiB por simplicidad
  responses:
  - ...machinecode

otherthings:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - vamos a ejecutar el cÃ³digo y descubrirlo
  - agreguÃ© un botÃ³n â©  a la secciÃ³n de cÃ³digo
  - "Â¿podrÃ¡s clickearlo? ğŸ™"
  events:
  - step [lda]

lda:
  run: |
    set((m) => m.$canRun = false);
  messages:
  - Â¡genial!
  - si prestaste atenciÃ³n, seguramente viste que [A] cambiÃ³ de $00 a $01
  - y [PC] cambiÃ³ de $4020 a $4022 ğŸ¤¯
  - estos son registros de CPU, ubicaciones rÃ¡pidamente accesibles
  - cada registro puede almacenar un solo byte (8 bits) de datos
  - con la excepciÃ³n de [PC] ("Program Counter") que ocupa 2 bytes
  responses:
  - Â¿cuÃ¡l es el propÃ³sito de cada registro? [registers]

registers:
  messages:
  - bueno, [A] significa "Accumulator" y su uso depende del programa
  - "[PC] siempre apunta a la prÃ³xima instrucciÃ³n a ejecutar"
  responses:
  - "entonces, con `LDA #$01` simplemente le dijiste al procesador que almacenara el nÃºmero $01 en [A]? ğŸ˜² [ldaexplanation]"
  - "(*) me dan curiosidad los otros: [X], [Y] y [SP] [theothers]"

theothers:
  run: |
    set((m) => m.$others = true);
  messages:
  - mÃ¡s adelante voy a hablar de eso, pero bÃ¡sicamente
  - "[X] e [Y] pueden almacenar cualquier valor, al igual que [A]"
  - tienen un significado especial cuando trabajas con direcciones de memoria ğŸ
  - y [SP] es el "Stack Pointer"
  responses:
  - <!m.$hasEnded> ...registers
  - <m.$hasEnded> ...finish

ldaexplanation:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - exactamente, LDA significa "LoaD Accumulator"
  - ğŸ’¸  todos los nÃºmeros con el prefijo $ estÃ¡n en notaciÃ³n hexadecimal
  - "ğŸ”¢  cualquier cosa con el prefijo # es un valor numÃ©rico literal"
  - ğŸ  cualquier otro nÃºmero refiere a una ubicaciÃ³n de memoria
  - Â¡ahora ejecuta la siguiente instrucciÃ³n! â©
  events:
  - step [sta]

sta:
  run: |
    set((m) => m.$canRun = false);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - STA significa "STore Accumulator"
  - y como puedes ver, escribe el contenido de [A] en una ubicaciÃ³n de memoria
  - en este ejemplo, en la direcciÃ³n $4070
  - asÃ­ que ahora la celda $4070 del Visor de Memoria tiene un $01
  - intenta ejecutar las instrucciones restantes â©
  events:
  - end [finish]

finish:
  run: |
    set((m) => m.$hasEnded = true);
    {{Bottom}}.setDelay(500);
  messages:
  - increÃ­ble, ahora conoces el funcionamiento bÃ¡sico de una CPU
  - clickea el butÃ³n â®  y ejecuta la simulaciÃ³n las veces que necesites
  - cuando quieras, podemos ir al siguiente nivel
  responses:
  - ğŸ’ª  creo que ya entendÃ­ todo [end]
  - <!m.$others> (*) Â¿y quÃ© onda con [X], [Y], and [SP]? [theothers]
  - (*) I don't like clicking buttons [clicking]

clicking:
  messages:
  - hmm...
  - you can navigate to the code section with `Alt+Up`
  - then hit `Alt+Enter`
  - and go back with `Alt+Left`
  responses:
  - ...finish
