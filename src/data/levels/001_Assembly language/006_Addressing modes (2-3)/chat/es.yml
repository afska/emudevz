---
main:
  run: |
    if (level.hasStoredContent) $.goTo("exercise");
    else {
      set((m) => {
        m.chat.stopBlock = locales.get("not_now");
        m.$canRun = false;
        m.$canEdit = false;
      });
      {{Bottom}}.setMemoryStart(0x0);
    }
  messages: []
  events:
  - compiled [lda]

lda:
  run: |
    bus.emit("step");
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - aquÃ­ es donde el direccionamiento se pone interesante ðŸ§
  - en el modo de direccionamiento "Zero Page,X", se da una direcciÃ³n de la pÃ¡gina cero
  - y luego se suma el valor de [X]
  - ejecuta las primeras dos instrucciones â©
  events:
  - step [zero1]

zero1:
  messages: []
  events:
  - step [zero2]

zero2:
  run: |
    set((m) => m.$canRun = false);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - esto terminÃ³ escribiendo $CD (el contenido de [A]) en $0062
  - que es el resultado de $60 + [X]
  - nota que hackeÃ© tu Visor de Memoria para que muestre la pÃ¡gina cero
  - puedes comprobarlo tÃº ðŸ‘€
  - corre las siguientes dos instrucciones â©
  events:
  - step [zero3]

zero3:
  messages: []
  events:
  - step [zero4]

zero4:
  run: |
    set((m) => m.$canRun = false);
  messages:
  - Â¿ves? la <misma> instrucciÃ³n (`STA $60,X`) tuvo dos resultados <diferentes> ðŸ¤¯
  - como [X] ahora es 3, escribiÃ³ en $0063
  responses:
  - Â¿quÃ© pasa si el resultado de la suma es mÃ¡s grande que un byte? [wrap]

wrap:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - la direcciÃ³n da la vuelta ðŸŽ
  - dÃ©jame mostrarte
  - ejecuta dos instrucciones mÃ¡s â©
  events:
  - step [wrap1]

wrap1:
  messages: []
  events:
  - step [wrap2]

wrap2:
  run: |
    set((m) => m.$canRun = false);
  run-after-messages: |
    set((m) => m.$canRun = true);
    {{Bottom}}.setMemoryStart(0x4020);
  messages:
  - como viste, escribiÃ³ $CD en $05
  - el prÃ³ximo modo de direccionamiento se llama "Absolute,X"
  - es la versiÃ³n absoluta de "Zero Page,X"
  - voy a cambiar el Visor de Memoria de vuelta a $4020 para que puedas verlo
  - termina de correr el cÃ³digo â©
  events:
  - step [rest1]

rest1:
  messages: []
  events:
  - step [rest2]

rest2:
  messages:
  - esto ha escrito $CD en $4052 ðŸ˜‹
  - ($4050 + el contenido de [X])
  responses:
  - Â¡muy bueno! Â¿puedo usar [Y] en vez de [X]? [yvariants]

yvariants:
  messages:
  - sÃ­, hay equivalentes de estos modos que usan [Y]
  - no todas las instrucciones los soportan, sin embargo ðŸ‘Ž
  - se llaman "Zero Page,Y" y "Absolute,Y"
  - Â¿quieres hacer algo divertido?
  responses:
  - mmm... Â¿sÃ­? [exercise]

exercise:
  run: |
    level.fillContentFromTemp();
    set((m) => {
      m.chat.stopBlock = null;
      m.$canRun = true;
      m.$canEdit = true;
      m.content.useTemp = false;
    });
    {{Bottom}}.setDelay(0);
  messages:
  - borra todo el cÃ³digo
  - construye un programa que grite por la memoria ðŸ˜±
  - eso significa, que escriba $AA exactamente 64 veces desde $4080 hasta $40BF
  - como siempre, cuando estÃ© listo, ejecuta el comando `test`
  responses: []
