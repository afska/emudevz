---
main:
  run: |
    if (m.$end) $.goTo("exercise");
    else {
      set((m) => {
        m.chat.stopBlock = locales.get("not_now");
        m.$canRun = false;
        m.$canEdit = false;
      });
    }
  messages:
  - if you didn't notice, all instructions can take one or zero arguments
  - and one compiled instruction can occupy 1, 2, or 3 bytes
  responses:
  - why are you telling me this? [why]

why:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - there are various ways to refer to these arguments
  - and they're called "addressing modes"
  - run the first instruction ⏩
  events:
  - step [implicit]

implicit:
  run: |
    set((m) => m.$canRun = false);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - the instruction `INX` takes no arguments, so it's only 1 byte
  - ([PC] went from $4020 to $4021)
  - this is called the "Implicit" addressing mode
  - the argument is <implied> by the instruction itself
  - keep going ⏩
  events:
  - step [immediate]

immediate:
  run: |
    set((m) => m.$canRun = false);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - "here, `LDA #$08` takes 1 byte as argument, so it's 2-byte long"
  - (the "operation code" and the eight)
  - that's the "Immediate" addressing mode
  - where the argument is a <literal> byte
  - keep going ⏩
  events:
  - step [absolute]

absolute:
  run: |
    set((m) => m.$canRun = false);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - "`LDA $C002` takes instead a memory address"
  - as it has a 2-byte argument, it compiles to 3 bytes
  - this is the "Absolute" addressing mode
  - where the argument is a <full> memory address
  - keep going ⏩
  events:
  - step [zeropage]

zeropage:
  run: |
    set((m) => m.$canRun = false);
  messages:
  - "`LDA $15` also takes a memory address"
  - but a short one, because it's only 1 byte
  - the full address would be $0015
  - that's the "Zero Page" addressing mode
  - where the argument is a <partial> memory address
  responses:
  - it looks like the same thing [samething]

samething:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - it's faster than the "Absolute" mode, as only one byte needs to be looked up
  - and takes up less space in the assembled code as well
  - but only the first page (the first 256 bytes) is accessible
  - keep going ⏩
  events:
  - step [relative]

relative:
  run: |
    set((m) => m.$canRun = false);
  messages:
  - branching instructions use the "Relative" addressing mode
  - these instructions take a single byte, which is used as an offset from the following instruction
  - look at the compiled code of `BNE @label` in $4028
  - $D0 is the opcode of `BNE`, and the $02 from $4029 is the jump offset
  - "this means that [PC] will jump to $402A + 2: directly into $402C, where @label starts"
  - (it'll skip the bytes of the two `INY`s)
  responses:
  - interesting, so that's how branching works [whoa]

whoa:
  messages:
  - last one is a bit tricky
  - I'm gonna explain it beforehand
  - coming soon!
  responses: []
