---
main:
  run: |
    if (m.$end) $.goTo("exercise");
    else {
      set((m) => {
        m.chat.stopBlock = locales.get("not_now");
        m.$canRun = false;
        m.$canEdit = false;
      });
    }
  messages:
  - hasta ahora, solo corrimos programas sin bifurcaciones
  - vamos a cambiar eso
  - el lenguaje ensamblador para 6502 tiene multiples instrucciones para bifurcar ğŸŒ²
  - todas ellas saltan cuando ciertas banderas estÃ¡n activadas o no
  responses:
  - (*) Â¿"para 6502"? ğŸ¤” [asm6502]
  - bueno y cÃ³mo salto [how]

asm6502:
  messages:
  - ese es el nombre del procesador de la NEEES, "6502"
  - cada lenguaje ensamblador estÃ¡ diseÃ±ado para una CPU especÃ­fica
  - con su propio conjunto de instrucciones
  - asÃ­ que, estamos escribiendo "lenguaje ensamblador para 6502" ğŸ™‚
  responses:
  - ...main

how:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - vamos a analizar `BNE`
  - ("Branch on Not Equal")
  - corre las primeras 5 instrucciones para ver quÃ© hacen â©
  events:
  - step [step1]

step1:
  messages: []
  events:
  - step [step2]

step2:
  messages: []
  events:
  - step [step3]

step3:
  messages: []
  events:
  - step [step4]

step4:
  messages: []
  events:
  - step [step5]

step5:
  run: |
    set((m) => m.$canRun = false);
  messages:
  - esto es lo que pasÃ³
  - "`CPX #3` activa la Bandera Zero si [X] es igual a 3"
  - "`BNE @decrement` salta a esa etiqueta si la Bandera Zero no estÃ¡ activada"
  - como [X] tiene un 7, entonces Z sigue siendo 0
  - y como Z es 0, `BNE @decrement` saltÃ³ ğŸ¦˜
  - ([X] y 3 eran "Not Equal", por eso el nombre)
  responses:
  - ah, ya veo [oh]

oh:
  run: |
    set((m) => m.$canRun = true);
  messages:
  - ahora, corre el resto del cÃ³digo â©
  events:
  - end [exercise]

exercise:
  run-after-messages: |
    level.fillContentFromTemp();
    set((m) => {
      m.$end = true;
      m.chat.stopBlock = null;
      m.$canEdit = true;
      m.content.useTempContent = false;
    });
  messages:
  - el opuesto de `BNE` es `BEQ`, que salta cuando los nÃºmeros son iguales
  - vamos a practicar ğŸ‘¾
  - borra el cÃ³digo actual
  - y construye un programa que lea el valor de $4080
  - si tiene un 7, escribe $EE en $40BF
  - si no, escribe $AA en $40BF
  - luego, ejecuta el comando `test`
  responses:
  - momento, Â¿cÃ³mo pruebo esto? ğŸ§ª [testing]
  - necesito ayuda [help]

testing:
  messages:
  - configurÃ© un generador de nÃºmeros aleatorios ğŸ”¢
  - cada vez que cambies/corras tu cÃ³digo, escribirÃ¡ un 7 o un byte aleatorio en $4080
  - con 50% de probabilidades cada cosa
  - asÃ­ que cuando sea 7, tu cÃ³digo deberÃ­a escribir $EE
  - y cuando no, $AA tendrÃ­a que ser escrito
  responses: []

help:
  messages:
  - ğŸ¦˜  siempre querrÃ¡s usar `BEQ` y `BNE` luego de una instrucciÃ³n de comparaciÃ³n (como `CPX`)
  - "`CPX` asigna el flag Z=1 si [X] es igual al valor, y luego `BEQ`/`BNE` saltan dependiendo de si Z es 1 o 0"
  - ğŸ·ï¸  recuerda que las etiquetas son ignoradas a menos que tengamos que saltar a alguna de ellas
  - ğŸ›‘  si alguna vez necesitas parar el programa, puedes poner una etiqueta al final del cÃ³digo
  - y usar una instrucciÃ³n de bifurcaciÃ³n para saltar a ella
  - o mÃ¡s fÃ¡cil, usa la instrucciÃ³n `BRK`, que interrumpe la ejecuciÃ³n ğŸ˜‰
  responses: []
