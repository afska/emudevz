---
main:
  run: |
    if (level.hasStoredContent) $.goTo("exercise");
    else {
      set((m) => {
        m.chat.stopBlock = locales.get("not_now");
        m.$canRun = false;
        m.$canEdit = false;
      });
    }
  messages:
  - la pila üìö  es una estructura LIFO ("Last In, First Out") que los programas usan para almacenar valores
  - la longitud actual de la pila es medida por el "Stack Pointer" ([SP])
  - en un procesador 6502, vive en la memoria entre $0100 y $01FF üêè
  - "[SP] inicialmente es $FF, que apunta al √∫ltimo byte de la pila ($01FF)"
  - cuando un byte se agrega a la pila, [SP] pasa a ser $FE (o ubicaci√≥n de memoria $01FE), y as√≠
  responses:
  - ¬øy c√≥mo puedo poner valores en ella? [put]

put:
  messages:
  - "puedes usar dos instrucciones:"
  - "‚¨ÜÔ∏è  `PHA` (\"PusH Accumulator\"), que pone [A] en la pila"
  - "‚¨áÔ∏è  `PLA` (\"PulL Accumulator\"), que saca el √∫ltimo byte de la pila, y lo carga en [A]"
  responses:
  - ¬øpuedes explicarme el c√≥digo de ejemplo? [example]

example:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - crea dos bucles ‚û∞
  - "`@save` pone n√∫meros impares entre $4080 y $4087"
  - y `@load` pone esos n√∫meros en orden inverso desde $4088 hasta $408F
  - el primero <pone> valores en la pila, el segundo <saca> valores de la pila
  - ahora tu depurador tiene una secci√≥n Pila üëÄ
  - ejecuta el c√≥digo y compru√©balo con tus propios ojos ‚è©
  responses:
  - buen√≠simo, ahora entiendo [exercise]
  - (*) ¬øpor qu√© `PLA` no saca el valor de la pila? [remove]

remove:
  messages:
  - lo "saca", solamente incrementando [SP]
  - el valor queda en memoria, no obstante üòÖ
  - no hay raz√≥n para quitarlo, ya que solo acceder√≠as a la pila con las instrucciones apropiadas
  responses:
  - ...example

exercise:
  run: |
    level.test.precode = "pretest.asm";
    level.fillContentFromTemp();
    set((m) => {
      m.chat.stopBlock = null;
      m.$canRun = true;
      m.$canEdit = true;
      m.content.useTempContent = false;
    });
  messages:
  - ahora, un ejercicio
  - tu pila tendr√° 2 valores precargados aleatorios
  - solo necesitas sacar y cargarlos en 2 direcciones de memoria consecutivas
  - luego, hacer un salto indirecto `JMP` ü¶ò
  - p. ej. si tu pila tiene -de arriba a abajo- $C4 y $3E, cuando tu programa finalice, [PC] deber√≠a valer $3EC4
  - corre `test` cuando est√© todo listo üòä
  responses: []
