---
main:
  run: |
    if (m.$end) $.goTo("exercise");
    else {
      set((m) => {
        m.chat.stopBlock = locales.get("not_now");
        m.$canRun = false;
        m.$canEdit = false;
      });
    }
  messages:
  - the stack ðŸ“š  is a LIFO structure ("Last In, First Out") which programs can use to store values
  - the current stack depth is measured by the "Stack Pointer" ([SP])
  - in a 6502 processor, it lives in memory between $0100 and $01FF ðŸ
  - "[SP] is initially $FF, which points to the last byte ($01FF)"
  - when a byte is pushed onto the stack, [SP] becomes $FE (or memory location $01FE), and so on
  responses:
  - and how can I put values on it? [put]

put:
  messages:
  - "you use two instructions:"
  - "â¬†ï¸  `PHA` (\"PusH Accumulator\"), which adds [A] to the stack"
  - "â¬‡ï¸  `PLA` (\"PulL Accumulator\"), which removes the last byte from the stack, and loads it in [A]"
  responses:
  - can you explain me the example code? [example]

example:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - it creates two loops âž°
  - "`@firstLoop` puts sequential numbers from $4080 to $4087"
  - and `@secondLoop` does the same in reverse order from $4088 to $408F
  - the former pushes values to the stack, the latter pulls values from the stack
  - now your debugger has a Stack section ðŸ‘€
  - run the code and check it out yourself â©
  responses:
  - nice, I get it now [exercise]
  - (*) why doesn't `PLA` remove the value from the stack? [remove]

remove:
  messages:
  - it "removes" it, by incrementing [SP]
  - the value is kept in memory though
  - there's no reason to remove it, as you'd only access the stack with the appropriate instructions
  responses:
  - ...example

exercise:
  run-after-messages: |
    level.fillContentFromTemp();
    set((m) => {
      m.$end = true;
      m.chat.stopBlock = null;
      m.$canEdit = true;
      m.content.useTempContent = false;
    });
    {{Bottom}}.setDelay(0);
  messages:
  - exercise!
  responses: []
