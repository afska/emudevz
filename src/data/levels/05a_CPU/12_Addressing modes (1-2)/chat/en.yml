---
main:
  messages:
  - remember the <addressing modes> from the assembly chapter?
  - <{compilation_full.png}>
  - well... it's time to emulate them ğŸ˜
  - I made a quick reference for you
  - check out ğŸ“„  ~/docs/cpu/addressing_modes.en.md~
  responses:
  - I'll definitely need you to explain this a bit further [explain]

explain:
  messages:
  - yeah
  - you can see every addressing mode has an <input> and an <output>
  - â¬…ï¸  the <input> is the operation's argument (what follows the opcode, remember?)
  - in `JMP ($4080)` the <input> would be $4080
  - â¡ï¸  the <output> is what the instructions end up actually receiving
  - (the `address` argument in your `JMP` instruction's `run(...)` function)
  - in this case, the <output> would be the result of performing a 16-bit read to address $4080
  responses:
  - âœ…  ok, let's code this [letscode]

letscode:
  messages:
  - actually I already coded some of these modes
  - so you'll only have to implement "Relative" and "Indirect"
  - you can grab the code from ğŸ“„  ~/tmpl/cpu/addressingModes.js~ and continue from there!
  - ğŸ“š  _-_implement the missing addressing modes_--_
  - ğŸ“š  _-_and export the object under the `addressingModes` key in _--_ğŸ“„ _-_ ~/code/index.js~_--_
  responses:
  - help me with the "Relative" mode ğŸ˜… [relative]
  - help me with the "Indirect" mode ğŸ˜… [indirect]

relative:
  messages:
  - ğŸ’¡  remember that it takes an "offset" (a signed byte)
  - signed bytes can be tricky to understand for humans
  - they use the "Two's component" notation, which is explained briefly in ğŸ“„  ~/lib/byte.js~
  - for example, if the offset is ~-3~, you would receive a 253
  - you can convert that 253 to ~-3~ using the `toS8` method
  - ğŸ’¡  also, to check for page crossing events, you will need `highByteOf(...)`
  responses:
  - ...letscode

indirect:
  messages:
  - you have a full implementation in the doc file ğŸ˜Š
  - just perform a `read16` with the address!
  responses:
  - ...letscode
