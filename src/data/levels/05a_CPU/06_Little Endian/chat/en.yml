---
main:
  messages:
  - sometimes, values are represented using more than 1 byte
  - e.g. when a CPU instruction has a 16-bit address as an argument
  - or when using the `RTS` instruction and the CPU needs to restore [PC] from the stack
  - in these cases, the Little Endian convention is used ğŸ”Œ
  - "that means: the least significant byte (\"low byte\") is stored first, then the most significant byte (\"high byte\")"
  - <{little_endian.png}>
  - |-
    ğŸ“š  implement this method in ğŸ  `CPUMemory`:
    **read16(address)**:
      **->** returns a 16-bit number
        - the low byte is obtained by reading `address` from memory
        - the high byte is obtained by reading ```javascript address+1```
  - |-
    ğŸ“š  and these two methods in ğŸ§±  `Stack`:
    **push16(bigNumber)**:
      **->** calls `push(...)` twice (first with the high byte of `bigNumber`, then with its low byte)
    **pop16()**:
      **->** returns a 16-bit number as a result of calling `pop()` two times (first the low byte, then the high one)
  - ğŸ’¡  remember to use ğŸ“„  ~/lib/byte.js~!
  responses: []
