---
main:
  messages:
  - a veces, los valores se representan usando m谩s de 1 byte
  - p. ej. cuando una instrucci贸n de CPU tiene una direcci贸n de 16 bits como argumento
  - o al usar la instrucci贸n `RTS` y la CPU tiene que restaurar [PC] desde la pila
  - en estos casos, se usa la convenci贸n <Little Endian> 
  - "eso quiere decir: el byte menos significativo (\"low byte\") se guarda primero, luego el m谩s significativo (\"high byte\")"
  - <{little_endian.png}>
  - |-
      implementa este m茅todo en `CPUMemory`:
    **read16(address)**:
      **->** retorna un n煤mero de 16 bits
        - el low byte se obtiene leyendo `address` de la memoria
        - el high byte se obtiene leyendo `address+1`
  - |-
      y estos dos m茅todos en `Stack`:
    **push16(bigNumber)**:
      **->** llama a `push(...)` dos veces (primero con el high byte de `bigNumber`, luego con su low byte)
    **pop16()**:
      **->** retorna un n煤mero de 16 bits como resultado de hacer `pop()` dos veces (primero el low byte, luego el high byte)
  -   隆recuerda usar   ~/lib/byte.js~!
  responses: []
