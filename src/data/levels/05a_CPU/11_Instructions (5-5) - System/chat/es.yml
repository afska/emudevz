---
main:
  messages:
  - solo quedan dos instrucciones ğŸ‰
  - "y una de ellas es bastante trivial: `NOP`"
  - "`NOP` significa \"No Operation\", Â¡y no hace nada!"
  - los desarrolladores de juegos usaban esto como un espacio reservado, o para introducir retrasos de tiempo para sincronizar sus sistemas
  - asÃ­ que, la Ãºltima es `BRK`, que genera un <Pedido de InterrupciÃ³n>
  responses:
  - Â¿quÃ© es una interrupciÃ³n? [interrupt]
  - <<level.isCompleted || m.$exercise>> ğŸ“š  llÃ©vame a la acciÃ³n [implement]

interrupt:
  messages:
  - es una seÃ±al que interrumpe el programa actual para manejar un evento especÃ­fico
  - cuando tal evento ocurre, la CPU guarda su estado ([PC] y registro de banderas) en la pila
  - y salta a una direcciÃ³n de memoria conocida (llamada "vector") asociada a ese evento
  - "en la NEEES, hay 3 eventos:"
  - "ğŸ”  <RESET>: Disparado cuando el sistema se enciende"
  - "ğŸ“¹  <NMI>: Disparado cuando la PPU termina de dibujar un frame"
  - "âœ‹  <IRQ>: Disparado por una instrucciÃ³n `BRK`, la APU, o hardware externo como mappers"
  responses:
  - Â¿puedes darme un ejemplo? ğŸ¤” [example]

example:
  messages:
  - Â¡sÃ­! imagina que eres un juego
  - necesitas mover tus sprites cuando la PPU termina de renderizar su frame actual, para evitar hacerlo mientras estÃ¡ dibujando (causando glitches ğŸ’¥ )
  - asÃ­ que, pones tu cÃ³digo que mueve sprites en -por ejemplo- la direcciÃ³n $90CC
  - esa serÃ¡ la ubicaciÃ³n de tu <manejador de interrupciones>
  - y luego te "suscribes" al evento <NMI> poniendo un puntero a $90CC en el vector de <NMI> (que es ~$FFFA/B~)
  - (en Little Endian, por lo que $FFFA guarda $CC y $FFFB guarda $90)
  responses:
  - Â¿quÃ© pasarÃ­a cuando un <NMI> ocurre? [nmi]

nmi:
  messages:
  - "en este ejemplo, cuando un <NMI> es disparado, la CPU:"
  - ğŸ§±  pone [PC] y las banderas en la pila
  - ğŸ  asigna ~I=1~, que desactiva las interrupciones del usuario
  - ğŸ  toma el valor $90CC de leer $FFFA y $FFFB (el vector de <NMI>)
  - ğŸ¦˜  salta a $90CC
  - ğŸš²  consume 7 ciclos haciendo todo esto
  - luego, el manejador de interrupciones moverÃ¡ los sprites y ejecutarÃ¡ `RTI` ("Return from Interrupt") para restaurar el estado anterior
  responses:
  - (*) Â¿quÃ© es eso de los 7 ciclos? ğŸš² [cycle]
  - (*) Â¿cuÃ¡l es el propÃ³sito de la bandera ~I~? ğŸ [iflag]
  - Â¡genial! creo que ya podrÃ­a implementarlo ğŸ˜ [implement]

cycle:
  messages:
  - es el tiempo que toma procesar una interrupciÃ³n ğŸ•–
  - no hablamos mucho de ciclos hasta ahora
  - solo te hice agregar unas propiedades misteriosas en la clase `CPU`, Â¿recuerdas?
  - esas llamadas `cycles` y `extraCycles`
  - voy a explicar mÃ¡s esto luego, lo prometo ğŸ˜…
  responses:
  - ...nmi

iflag:
  messages:
  - es la bandera "Interrupt Disable", y como su nombre indica, desactiva las interrupciones
  - el sistema asigna ~I=1~ para que los manejadores de interrupciones no sean... mmm... interrumpidos ğŸ˜…
  - |-
    la cosa es que... solo los eventos <IRQ> se pueden desactivar
    <RESET> no puede ser ignorada por obvias razones
    <NMI> quiere decir "Non-maskable interrupt" y es muy importante, por lo que no puede ser "masked" (o sea, desactivada)
  responses:
  - ...nmi

implement:
  run: |
    set((m) => m.$exercise = true);
  messages:
  - genial
  - vamos a modelar las interrupciones como objetos `{ id, vector }`
  - revisa ğŸ“„  ~/lib/interrupts.js~
  - |-
    ğŸ“š  _-_agrega este mÃ©todo a tu `CPU`:_--_
    *_-_*interrupt(interrupt, withBFlag = false)**:_--_
      *_-_*->** si ~interrupt.id === "IRQ"~ y ~I=1~, retorna 0_--_
        _-_(la interrupciÃ³n es ignorada)_--_
      *_-_*->** pone [PC] en la pila_--_
      *_-_*->** pone el byte de banderas en la pila_--_
        _-_(si ~withBFlag~ es ~true~, el valor se agrega a la pila con el bit 4 encendido)_--_
        _-_(de lo contrario, se agrega tal cual estÃ¡)_--_
      *_-_*->** avanza 7 ciclos (~this.cycle += 7~)_--_
      *_-_*->** asigna ~I=1~ en el registro de banderas_--_
      *_-_*->** asigna [PC] = al resultado de leer las direcciones ~interrupt.vector~ y ~interrupt.vector+1~ en <Little Endian>_--_
        _-_(recuerda que tienes un mÃ©todo ~read16(...)~ para eso)_--_
      *_-_*->** retorna 7_--_
  responses:
  - Â¿y ~BRK~? [brk]

brk:
  messages:
  - |-
    ğŸ“š  _-_puedes implementar la instrucciÃ³n `BRK` solo llamando
      ```javascript cpu.interrupt(interrupts.IRQ, true)```_--_
  responses: []
