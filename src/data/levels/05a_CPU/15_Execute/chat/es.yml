---
main:
  messages:
  - implementemos un mÃ©todo `step()` que ejecute la siguiente operaciÃ³n
  - leerÃ¡ el siguiente opcode y argumentos desde ğŸ¤–  <PRG-ROM>
  - llamarÃ¡ a la <instrucciÃ³n> correcta y al <modo de direccionamiento> adecuado
  - e incrementarÃ¡ los contadores de ciclos
  responses:
  - prometiste que explicarÃ­as ciclos ğŸš² [cycles]
  - <<level.isCompleted || m.$exercise>> ğŸ“š  llÃ©vame a la acciÃ³n [rightway]

cycles:
  messages:
  - Â¡y lo harÃ©!
  - el tiempo que le toma a la CPU ejecutar una acciÃ³n se mide en <ciclos>
  - los ciclos son muy importantes si queremos construir un emulador "cycle-accurate" (Â¡no queremos!)
  - pero igualmente sirven para mantener las diferentes unidades (CPU, PPU, APU) en sincronÃ­a ğŸ”„
  - por lo que cada opcode sabe cuÃ¡ntos ciclos deberÃ­a tomar
  responses:
  - (*) Â¿por quÃ© no queremos construir un emulador "cycle-accurate"? [accuracy]
  - âœ”ï¸  bueno, Â¿cÃ³mo hacemos? [rightway]

accuracy:
  messages:
  - porque es una tarea compleja ğŸ¥µ
  - y puede ser especialmente complicada para gente sin conocimientos previos en emulaciÃ³n
  - existen juegos "difÃ­ciles de emular" que demandan precisiÃ³n para funcionar
  - pero la mayorÃ­a de los otros simplemente funciona bien, asÃ­ que no lo necesitaremos de todas formas
  responses:
  - ...cycles

rightway:
  run: |
    set((m) => m.$exercise = true);
  messages:
  - |-
    ğŸ“š  _-_primero, vamos a agregar estos mÃ©todos a tu `CPU`:_--_
    **_fetchOperation()**:
      **->** lee un byte de la ubicaciÃ³n de memoria apuntada por [PC]
        (llamemos esto ~opcode~)
      **->** encuentra la operaciÃ³n relacionada con ese opcode:
        ~this.operations[opcode]~
        (llamemos esto ~operation~)
      **->** si ~operation~ no existe, tira un error "Invalid opcode."
      **->** incrementa [PC]
      **->** retorna ~operation~
    **_fetchInput(operation)**:
      **->** lee 0, 1 (usando ~read(...)~) o 2 bytes (usando ~read16(...)~) de la ubicaciÃ³n de memoria apuntada por [PC], dependiendo de ~operation.addressingMode.inputSize~
        (llamemos esto ~input~)
      **->** incrementa [PC] (0, 1, o 2 veces) para saltear esos bytes
      **->** retorna ~input~ (o ~null~)
    **_fetchArgument(operation, input)**:
      **->** retorna el resultado de procesar ~input~ con el modo de direccionamiento
        - si ~operation.instruction.argument === "value"~, deberÃ­a ser:
            ~operation.addressingMode.getValue(this, input, operation.hasPageCrossPenalty)~
        - si no:
            ~operation.addressingMode.getAddress(this, input, operation.hasPageCrossPenalty)~
    **_addCycles(operation)**:
      **->** calcula cuÃ¡ntos ciclos tomÃ³ la ~operation~:
        ~operation.cycles + this.extraCycles~
        (llamemos esto ~cycles~)
      **->** actualiza los contadores de ciclos:
        ~this.cycle += cycles;~
        ~this.extraCycles = 0;~
      **->** retorna ~cycles~
  responses:
  - Â¿y el mÃ©todo `step()` que mencionaste? [step]

step:
  messages:
  - |-
    _-_nuestro mÃ©todo `step()` deberÃ­a salir fÃ¡cil, usando los otros:
      ```javascript step() {
        const originalPC = this.pc.getValue();
        
        const operation = this._fetchOperation();
        const input = this._fetchInput(operation);
        const argument = this._fetchArgument(operation, input);

        if (this.logger != null) {
          this.logger(
            this,
            originalPC,
            operation,
            input,
            argument
          )
        }
        
        operation.instruction.run(this, argument);
        return this._addCycles(operation);
      }```_--_
  responses: []
