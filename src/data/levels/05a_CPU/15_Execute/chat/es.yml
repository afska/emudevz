---
main:
  messages:
  - implementemos un mÃ©todo `step()` que ejecute la siguiente <operaciÃ³n>
  - leerÃ¡ el siguiente opcode y argumentos desde ðŸ¤–  PRG-ROM
  - llamarÃ¡ a la instrucciÃ³n correcta y al modo de direccionamiento adecuado
  - e incrementarÃ¡ los contadores de ciclos
  responses:
  - prometiste que explicarÃ­as ciclos ðŸš² [cycles]

cycles:
  messages:
  - Â¡y lo harÃ©!
  - el tiempo que le toma a la CPU ejecutar una acciÃ³n se mide en ciclos
  - los ciclos son muy importantes si queremos construir un emulador "cycle-accurate" (Â¡no queremos!)
  - pero igualmente sirven para mantener las diferentes unidades (CPU, PPU, APU) en sincronÃ­a ðŸ”„
  - por lo que cada opcode sabe cuÃ¡ntos ciclos deberÃ­a tomar
  responses:
  - (*) Â¿por quÃ© no queremos construir un emulador "cycle-accurate"? [accuracy]
  - âœ…  bueno, Â¿cÃ³mo hacemos? [exercise]

accuracy:
  messages:
  - porque es una tarea compleja ðŸ¥µ
  - y puede ser especialmente complicada para gente sin conocimientos previos en emulaciÃ³n
  - existen juegos "difÃ­ciles de emular" que demandan precisiÃ³n para funcionar
  - pero la mayorÃ­a de los otros simplemente funciona bien, asÃ­ que no lo necesitaremos de todas formas
  responses:
  - ...cycles

exercise:
  messages:
  - |-
    ðŸ“š  primero, vamos a agregar estos mÃ©todos a tu ðŸ§   `CPU`:
    **_fetchOperation()**:
      **->** lee un byte de la direcciÃ³n de memoria apuntada por [PC]
        (llamemos a esto `opcode`)
      **->** encuentra la operaciÃ³n relacionada con ese opcode:
        ```javascript this.operations[opcode]```
        (llamemos a esto `operation`)
      **->** si `operation` no existe, tira un error "Invalid opcode."
      **->** incrementa [PC]
      **->** retorna `operation`
    **_fetchInput(operation)**:
      **->** lee 0, 1 (usando `read(...)`) o 2 bytes (usando `read16(...)`) de la direcciÃ³n de memoria apuntada por [PC], dependiendo de ```javascript operation.addressingMode.inputSize```
        (llamemos a esto `input`)
      **->** incrementa [PC] (~0~, 1, o 2 veces) para saltear esos bytes
      **->** retorna `input` (o ```javascript null```)
    **_fetchArgument(operation, input)**:
      **->** retorna el resultado de procesar `input` con el modo de direccionamiento
        - si ```javascript operation.instruction.argument === "value"```, deberÃ­a ser:
            ```javascript operation.addressingMode.getValue(this, input, operation.hasPageCrossPenalty)```
        - si no:
            ```javascript operation.addressingMode.getAddress(this, input, operation.hasPageCrossPenalty)```
    **_addCycles(operation)**:
      **->** calcula cuÃ¡ntos ciclos tomÃ³ la `operation`:
        ```javascript operation.cycles + this.extraCycles```
        (llamemos a esto `cycles`)
      **->** actualiza los contadores de ciclos:
        ```javascript this.cycle += cycles;```
        ```javascript this.extraCycles = 0;```
      **->** retorna `cycles`
  responses:
  - Â¿y el mÃ©todo `step()` que mencionaste? [step]

step:
  messages:
  - |-
    ðŸ“š  nuestro mÃ©todo `step()` deberÃ­a salir fÃ¡cil, usando los otros:
      ```javascript step() {
        const originalPC = this.pc.getValue();
        
        const operation = this._fetchOperation();
        const input = this._fetchInput(operation);
        const argument = this._fetchArgument(operation, input);

        if (this.logger != null) {
          this.logger(
            this,
            originalPC,
            operation,
            input,
            argument
          )
        }
        
        operation.instruction.run(this, argument);
        return this._addCycles(operation);
      }```
  responses: []
