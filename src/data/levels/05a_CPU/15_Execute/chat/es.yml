---
main:
  messages:
  - implementemos un mÃ©todo `step()` que ejecute la siguiente <operaciÃ³n>
  - leerÃ¡ el siguiente opcode y argumentos desde ğŸ¤–  <PRG-ROM>
  - llamarÃ¡ a la <instrucciÃ³n> correcta y al <modo de direccionamiento> adecuado
  - e incrementarÃ¡ los contadores de ciclos
  responses:
  - prometiste que explicarÃ­as ciclos ğŸš² [cycles]
  - <<level.isCompleted || m.$exercise>> ğŸ“š  llÃ©vame a la acciÃ³n [rightway]

cycles:
  messages:
  - Â¡y lo harÃ©!
  - el tiempo que le toma a la CPU ejecutar una acciÃ³n se mide en <ciclos>
  - los ciclos son muy importantes si queremos construir un emulador "cycle-accurate" (Â¡no queremos!)
  - pero igualmente sirven para mantener las diferentes unidades (CPU, PPU, APU) en sincronÃ­a ğŸ”„
  - por lo que cada opcode sabe cuÃ¡ntos ciclos deberÃ­a tomar
  responses:
  - (*) Â¿por quÃ© no queremos construir un emulador "cycle-accurate"? [accuracy]
  - âœ”ï¸  bueno, Â¿cÃ³mo hacemos? [rightway]

accuracy:
  messages:
  - porque es una tarea compleja ğŸ¥µ
  - y puede ser especialmente complicada para gente sin conocimientos previos en emulaciÃ³n
  - existen juegos "difÃ­ciles de emular" que demandan precisiÃ³n para funcionar
  - pero la mayorÃ­a de los otros simplemente funciona bien, asÃ­ que no lo necesitaremos de todas formas
  responses:
  - ...cycles

rightway:
  run: |
    set((m) => m.$exercise = true);
  messages:
  - |-
    ğŸ“š  _-_primero, vamos a agregar estos mÃ©todos a tu `CPU`:_--_
    *_-_*_fetchOperation()**:_--_
      *_-_*->** lee un byte de la ubicaciÃ³n de memoria apuntada por [PC]_--_
        _-_(llamemos a esto ~opcode~)_--_
      *_-_*->** encuentra la operaciÃ³n relacionada con ese opcode:_--_
        _-_~this.operations[opcode]~_--_
        _-_(llamemos a esto ~operation~)_--_
      *_-_*->** si ~operation~ no existe, tira un error "Invalid opcode."_--_
      *_-_*->** incrementa [PC]_--_
      *_-_*->** retorna ~operation~_--_
    *_-_*_fetchInput(operation)**:_--_
      *_-_*->** lee 0, 1 (usando ~read(...)~) o 2 bytes (usando ~read16(...)~) de la ubicaciÃ³n de memoria apuntada por [PC], dependiendo de ~operation.addressingMode.inputSize~_--_
        _-_(llamemos a esto ~input~)_--_
      *_-_*->** incrementa [PC] (0, 1, o 2 veces) para saltear esos bytes_--_
      *_-_*->** retorna ~input~ (o ~null~)_--_
    *_-_*_fetchArgument(operation, input)**:_--_
      *_-_*->** retorna el resultado de procesar ~input~ con el modo de direccionamiento_--_
        _-_- si ~operation.instruction.argument === "value"~, deberÃ­a ser:_--_
            _-_~operation.addressingMode.getValue(this, input, operation.hasPageCrossPenalty)~_--_
        _-_- si no:_--_
            _-_~operation.addressingMode.getAddress(this, input, operation.hasPageCrossPenalty)~_--_
    *_-_*_addCycles(operation)**:_--_
      *_-_*->** calcula cuÃ¡ntos ciclos tomÃ³ la ~operation~:_--_
        _-_~operation.cycles + this.extraCycles~_--_
        _-_(llamemos a esto ~cycles~)_--_
      *_-_*->** actualiza los contadores de ciclos:_--_
        _-_~this.cycle += cycles;~_--_
        _-_~this.extraCycles = 0;~_--_
      *_-_*->** retorna ~cycles~_--_
  responses:
  - Â¿y el mÃ©todo `step()` que mencionaste? [step]

step:
  messages:
  - |-
    _-_nuestro mÃ©todo `step()` deberÃ­a salir fÃ¡cil, usando los otros:
      ```javascript step() {
        const originalPC = this.pc.getValue();
        
        const operation = this._fetchOperation();
        const input = this._fetchInput(operation);
        const argument = this._fetchArgument(operation, input);

        if (this.logger != null) {
          this.logger(
            this,
            originalPC,
            operation,
            input,
            argument
          )
        }
        
        operation.instruction.run(this, argument);
        return this._addCycles(operation);
      }```_--_
  responses: []
