---
main:
  messages:
  - only two instructions left ğŸ‰
  - "and one of them is pretty trivial: `NOP`"
  - "`NOP` means \"No Operation\", and it does nothing!"
  - game developers used this as a placeholder, or to introduce timing delays to synchronize their systems
  - so, last one is `BRK` which generates an <Interrupt Request>
  responses:
  - what's an interrupt? [interrupt]

interrupt:
  messages:
  - it's a signal that interrupts the current program in order to handle a specific event
  - when such event happens, the CPU saves its state ([PC] and flags) in the stack
  - and jumps to a well-known memory location (called "vector") associated with that event
  - "in the NEEES, there are 3 events:"
  - "ğŸ”  <RESET>: Triggered when the system is turned on"
  - "ğŸ“¹  <NMI>: Triggered when the PPU finishes drawing a frame"
  - "âœ‹  <IRQ>: Triggered after a `BRK` instruction"
  responses:
  - can you give me an example? ğŸ¤” [example]

example:
  messages:
  - sure! imagine you're a game
  - you need to move your sprites when the PPU finishes drawing its current frame
  - to avoid doing it while it draws (causing glitches ğŸ’¥ )
  - so, you put your sprite moving code in -for example- address $90CC
  - that will be the location of your <interrupt handler>
  - and then you "subscribe" to the <NMI> event by placing a pointer to $90CC in <NMI>'s vector (which is $FFFA/B)
  - (in Little Endian, so $FFFA holds $CC and $FFFB holds $90)
  responses:
  - what would happen when an <NMI> occurs? [nmi]

nmi:
  messages:
  - "in this example, when the <NMI> is triggered, the CPU will:"
  - ğŸ§±  push [PC] and the flags onto the stack
  - ğŸ  set ~I=1~, which disables user interrupts
  - ğŸ§±  grab the value $90CC by reading $FFFA and $FFFB (<NMI>'s vector)
  - ğŸ¦˜  jump to $90CC
  - ğŸš²  consume 7 cycles while doing all this
  - then, the interrupt handler will move the sprites and run `RTI` ("Return from Interrupt") to restore the previous state
  responses:
  - (*) what about the 7-cycle stuff? ğŸš² [cycle]
  - (*) what's the purpose of the I flag? ğŸ [iflag]
  - great! I think I'm ready to implement it ğŸ˜ [implement]

cycle:
  messages:
  - that's time it takes to process an interrupt ğŸ•–
  - we didn't talk much about cycles so far
  - I've only made you add two mysterious properties to the `CPU` class, remember?
  - those called `cycles` and `extraCycles`
  - I'll explain this further later, I promise ğŸ˜…
  responses:
  - ...nmi

iflag:
  messages:
  - it's the "Interrupt Disable" flag, and as the name says, it disables interrupts
  - the systems sets ~I=1~ so interrupts handlers don't get... hmm... interrupted ğŸ˜…
  - |-
    the thing is... only <IRQ> events can be disabled
    <RESET> can't be ignored for obvious reasons
    <NMI> stands for "Non-maskable interrupt" and it's very important, so it can't be masked (aka "disabled")
  responses:
  - ...nmi

implement:
  messages:
  - awesome
  - we'll model interrupts as `{ id, vector }` objects
  - check out ~/lib/interrupts.js~
  - |-
    ğŸ“š  add this method to your `CPU`:
    **interrupt(interrupt, withBFlag = false)**:
      __-> if interrupt.id === "IRQ" and I=1, returns 0
        (the interrupt is ignored)
      -> pushes [PC] onto the stack
      -> pushes the flags onto the stack
        (if <withBFlag> is true, the flags byte should have bit 4 on)
      -> increments 7 cycles (this.cycles += 7)
      -> sets I=1 in the flags register
      -> sets [PC] = the result of reading the addresses (interrupt.vector) and (interrupt.vector + 1) in Little Endian
        (remember that you have a *read16* method)
      -> returns 7__
  run-after-messages: |
    store.dispatch.savedata.openFile("/lib/interrupts.js");
  responses:
  - and BRK? [brk]

brk:
  messages:
  - you can implement the `BRK` instruction just by calling `cpu.interrupt(interrupts.IRQ, true)`
  responses: []
