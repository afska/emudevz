---
main:
  messages:
  - tambiÃ©n necesitas emular el bus de memoria
  - la CPU tiene 2 KiB de RAM ğŸ
  - pero el espacio direccionable completo es 64 KiB
  - identificamos una ubicaciÃ³n de memoria con una <direcciÃ³n de memoria> (un nÃºmero de 16 bits)
  responses:
  - entonces, si solo 2 KiB son RAM de verdad, Â¿quÃ© hay en los otros 62 KiB? ğŸ¤¨ [other62]

other62:
  messages:
  - otras cosas, como espejos de RAM, E/S mapeada en memoria y la informaciÃ³n del cartucho
  - el mapa de memoria tiene una estructura muy especÃ­fica, mira ~/docs/cpu_memory.es.md~
  run-after-messages: |
    store.dispatch.savedata.openFile("/docs/cpu_memory.es.md");
  responses:
  - (*) Â¿quÃ© es "E/S mapeada en memoria"? ğŸ—ºï¸ [io]
  - ğŸ‘Œ  ya veo... Â¿quÃ© necesito implementar? [implement]

io:
  messages:
  - un esquema en el cual la CPU estÃ¡ conectada a dispositivos fÃ­sicos
  - por ejemplo...
  - leer $4016 leerÃ¡ los botones presionados del ğŸ®  mando
  - escribir los registros de la ğŸ–¥ï¸  PPU en $2000-$2007 modificarÃ¡ la pantalla
  - escribir los registros de la ğŸ”Š  APU en $4000-$4013 producirÃ¡ sonidos
  - leer $8000 probablemente leerÃ¡ el primer byte de <PRG-ROM> del ğŸ’¾  cartucho
  responses:
  - ...other62

implement:
  messages:
  - por ahora, solo vamos a implementar los dos primeros rangos del mapa de memoria
  - crea una clase `CPUMemory` con un constructor
  - deberÃ­a asignar una propiedad `ram` (un `Uint8Array` de 2048 bytes)
  - |-
    implementa estos dos mÃ©todos:
    **read(address)**:
      __si <address> estÃ¡ dentro de $0000-$07FF, retorna el byte de <ram>
      si <address> estÃ¡ dentro de $0800-$1FFF, retorna un byte espejado de <ram>
        (por ej. $0802 se vuelve $0002, $1023 se vuelve $0023)
      caso contrario, retorna 0__
    **write(address, byte)**:
      __similar a *read*, pero escribe el <byte> en lugar de retornar__
  - |-
    luego, agrega al constructor de tu `CPU`:
    ```javascript this.memory = new CPUMemory();```
  responses:
  - necesito ayuda con los bytes espejados ğŸ“ [help]

help:
  messages:
  - para saber quÃ© direcciÃ³n leer
  - tienes que sustraer el inicio del rango (el ~0x0800~ de ~0x0800~-~0x1FFF~)
  - luego, usa el operador ~%~ (resto) con el tamaÃ±o de la secciÃ³n de memoria que queremos espejar
  - |-
    por ejemplo, para calcular el espejado del 4to rango, harÃ­amos:
    ```javascript (address - 0x2008) % 0x0008```
  responses: []
