---
main:
  messages:
  - Â¿recuerdas los <modos de direccionamiento> del capÃ­tulo de ensamblador?
  - bueno... es hora de emularlos ğŸ˜
  - hice una guÃ­a rÃ¡pida para ti
  - revisa ğŸ“„  ~/docs/cpu/addressing_modes.es.md~
  run-after-messages: |
    store.dispatch.savedata.openFile("/docs/cpu/addressing_modes.es.md");
  responses:
  - definitivamente voy a necesitar que me expliques esto un poco mÃ¡s [explain]

explain:
  messages:
  - seh
  - puedes ver que cada modo de direccionamiento tiene una <entrada> y una <salida>
  - â¬…ï¸  la <entrada> es el argumento (lo que sigue despuÃ©s del opcode, Â¿recuerdas?)
  - en `JMP ($4080)` la <entrada> serÃ­a $4080
  - â¡ï¸  la <salida> es lo que las instrucciones terminan recibiendo en realidad
  - (el argumento `address` en la funciÃ³n `run(...)` de tu instrucciÃ³n `JMP`)
  - en este caso, la <salida> serÃ­a el resultado de realizar una lectura de 16 bits a la direcciÃ³n $4080
  responses:
  - no tan asÃ­, Â¿quÃ© es ese "page boundary bug"? ğŸ [pageboundary]

pageboundary:
  messages:
  - bÃ¡sicamente, la unidad de hardware se lanzÃ³ con un fallo en el modo "Indirect"
  - y si queremos emular el hardware precisamente... tenemos tambiÃ©n que emular los bugs ğŸ˜…
  responses:
  - (*) Â¿no puedo simplemente arreglar el bug? [fix]
  - âœ”ï¸  vamos a programar esto [letscode]

fix:
  messages:
  - puedes, pero estarÃ­as rompiendo la compatibilidad con algunos juegos que dependen (ya sea accidentalmente o intencionalmente) de ese bug
  responses:
  - ...pageboundary

letscode:
  messages:
  - en realidad ya codifiquÃ© algunos de estos modos
  - por lo que solo tienes que implementar "Relative" e "Indirect"
  - Â¡puedes tomar el cÃ³digo de ğŸ“„  ~/docs/cpu/example_addressing_modes.js~ y continuar desde ahÃ­!
  - ğŸ“š  implementa los modos de direccionamiento restantes
  - y exporta el objeto bajo la clave `addressingModes` en ~/code/index.js~
  responses:
  - ayÃºdame con el modo "Relative" ğŸ˜… [relative]
  - ayÃºdame con el modo "Indirect" ğŸ˜… [indirect]

relative:
  messages:
  - ğŸ’¡  recuerda que toma un "desplazamiento" (un byte con signo)
  - los bytes con signo pueden ser complicados de entender para los humanos
  - usan la notaciÃ³n "Two's component", que estÃ¡ explicada brevemente en ~/lib/byte.js~
  - por ejemplo, si el desplazamiento es ~-3~, recibirÃ­as un 253
  - puedes convertir ese 253 en ~-3~ usando el mÃ©todo `toS8`
  - ğŸ’¡  ademÃ¡s, para detectar si se cruza de pÃ¡gina, vas a necesitar `highByteOf`
  responses:
  - ...letscode

indirect:
  messages:
  - tienes una implementaciÃ³n completa en el archivo de documentaciÃ³n ğŸ˜Š
  - es pseudocÃ³digo, claro, pero vas a ser capaz de hacerlo funcionar
  responses:
  - ...letscode
