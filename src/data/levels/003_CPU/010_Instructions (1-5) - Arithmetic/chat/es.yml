---
main:
  messages:
  - "hay 3 tipos de instrucciones:"
  - "ğŸš«  instrucciones que esperan <cero argumentos>"
  - "ğŸ  instrucciones que esperan <una direcciÃ³n de memoria>"
  - "ğŸ”¢  instrucciones que esperan <un valor>"
  - voy a ejemplificar esto implementando 3 instrucciones comunes en un formato particular
  - Â¡mira tu archivo ğŸ“„  ~/docs/cpu/example_instructions.js~!
  responses:
  - bueno... Â¿cuÃ¡ntas instrucciones aritmÃ©ticas hay? [howmany]

howmany:
  messages:
  - son 16 en total, Â¡pero ya programÃ© 2 por ti! ğŸ˜
  - y algunas de ellas son muy similares
  - ğŸ“š  crea un objeto siguiendo el mismo formato que el ejemplo
  - implementa cada una de las 16 instrucciones aritmÃ©ticas sobre Ã©l
  - y expÃ³rtalo bajo la clave `instructions` en ~/code/index.js~
  - necesitas documentaciÃ³n acerca de quÃ© deberÃ­a hacer cada instrucciÃ³n
  - asÃ­ que revisa ğŸ“„  ~/docs/cpu/instructions.es.md~
  run-after-messages: |
    store.dispatch.savedata.openFile("/docs/cpu/instructions.es.md");
  responses:
  - necesito ayuda para mover bits ğŸ˜… [bits]
  - necesito ayuda para actualizar las banderas Z y N ğŸ˜… [flags]

bits:
  messages:
  - usa el operador ~<<~ para mover bits a la izquierda, y ~>>~ para mover bits a la derecha
  - por ejemplo
  - ~0b00001100 << 1~ producirÃ­a ~0b00011000~
  - y ~0b01000001 >> 1~ producirÃ­a ~0b00100000~
  responses:
  - asÃ­ es como mueves bits, Â¿pero cÃ³mo los rotarÃ­as? [rotation]

rotation:
  messages:
  - para rotar bits a la derecha (digamos, ~0b00000001 >> 1~), tienes que poner el bit 0 (que se pierde luego de mover los bits) en la Ãºltima posiciÃ³n (bit 7) 
  - |-
    por lo que, si tienes un `number`, puedes hacer:
      ```javascript byte.setBit(number >> 1, 7, byte.getBit(number, 0))```
  - |-
    o, sin usar la biblioteca de bytes:
      ```javascript (number >> 1) | ((number & 1) << 7)```
  - ten en cuenta que asÃ­ no es como funcionan `ROL` y `ROR`, ya que esas rotan usando la bandera ~C~
  responses:
  - ...howmany

flags:
  messages:
  - en casi todas las instrucciones que producen un valor, las banderas ~Z~ y ~N~ son actualizadas
  - deberÃ­as asignar ~Z=1~ cuando el valor producido es 0, y ~Z=0~ en caso contrario
  - y ademÃ¡s, asignar ~N=1~ cuando el byte es negativo, y ~N=0~ cuando no lo es
  - ya tienes mÃ©todos para esta tarea, solo usa `cpu.flags.updateZeroAndNegative(...)`!
  responses:
  - ...howmany
