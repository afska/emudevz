main:
  messages:
  - el scrolling es una caracterÃ­stica de la PPU que permite a los desarrolladores mover el fondo
  - implementarlo en un emulador NEEES es difÃ­cil ğŸ¥µ
  - no porque sea difÃ­cil mover el fondo, sino porque los registros de desplazamiento se comportan de maneras extraÃ±as
  - mucha gente lo ha intentado, pero solo los elegidos pudieron lograrlo
  responses:
  - Â¿tienes un plan? [plan]
  - <<level.isCompleted || m.$exercise>> ğŸ“š llÃ©vame a la acciÃ³n [proceed]

plan:
  messages:
  - sÃ­, podemos hacerlo juntos
  - intentarÃ© ayudarte al abstraer las partes complicadas en una biblioteca
  - tomarÃ¡ un tiempo
  - mientras tanto, puedes agregar una implementaciÃ³n bÃ¡sica del scrolling que no funcionarÃ¡ para todos los juegos
  - Â¡pero serÃ¡ suficiente para la mayorÃ­a de ellos!
  responses:
  - suena bien, Â¿cÃ³mo funciona el scrolling? [good]

good:
  messages:
  - bueno, los juegos en realidad no mueven <el fondo>
  - mueven una ventana imaginaria contra el fondo estÃ¡tico
  - eso es suficiente para crear la idea de movimiento ğŸŒ€
  responses:
  - Â¿y cÃ³mo se mueve la ventana? [viewport]

viewport:
  messages:
  - asÃ­
  - <{3rdparty_nametable_scrolling.png}>
  - los juegos escriben en ğŸ“œ  `PPUScroll` la posiciÃ³n de la ventana
  - escriben dos veces, primero para la <coordenada X>, luego para la <coordenada Y>
  - y la PPU mueve la ventana, dibujando solo parte de las name tables afectadas
  responses:
  - entonces... si los juegos escriben dos veces, la PPU tiene que recordar quÃ© coordenada estÃ¡n configurando, Â¿cierto? [twice]

twice:
  messages:
  - exacto
  - Â¿recuerdas cÃ³mo funciona ğŸ“  `PPUAddr`? Â¿con un `latch` que cambia despuÃ©s de cada escritura?
  - bueno, asÃ­
  - Â¡de hecho, usa ese mismo `latch`!
  responses:
  - entiendo... [isee]

isee:
  messages:
  - los primeros juegos de NEEES solo se desplazaban en una direcciÃ³n
  - los juegos con <mirroring horizontal> de name tables solo se desplazaban <verticalmente>
  - y los juegos con <mirroring vertical> de name tables solo se desplazaban <horizontalmente>
  - <{3rdparty_vertical_horizontal.png}>
  responses:
  - no entiendo, si solo hay dos name tables fÃ­sicas, Â¿cÃ³mo logran los juegos tener mapas largos? [long]

long:
  messages:
  - actualizan partes del fondo progresivamente cuando la ventana no estÃ¡ enfocada en ellas
  - por cierto, la posiciÃ³n de la ventana se basa en la <name table base>
  - recuerda que los primeros dos bits de ğŸ›ï¸  `PPUCtrl` seleccionan la name table actual
  - (tienes eso mapeado como `registers.ppuCtrl.nameTableId`)
  - asÃ­ que, si la name table base es 1, significa que la ventana deberÃ­a comenzar en la name table posicionada en $2400
  - <{3rdparty_scrolled_nametables.png}>
  responses:
  - suficiente charla, Â¿cÃ³mo procedemos? [proceed]

proceed:
  run: |
    set((m) => m.$exercise = true);
  messages:
  - (de nuevo, ESTO NO ES EXACTAMENTE CORRECTO, Â¡pero funcionarÃ¡ por ahora!)
  - |-
    ğŸ“š  _-_modifica estos mÃ©todos de `PPUScroll`:_--_
      *_-_*onLoad()**:_--_
        *_-_*->** establece ~this.x = 0~_--_
        *_-_*->** establece ~this.y = 0~_--_
      *_-_*onWrite(value)**:_--_
        *_-_*->** si el ~latch~ de PPUAddr es ~false~:_--_
          *_-_*->** escribe el ~valor~ en ~this.x~_--_
        *_-_*->** si es ~true~:_--_
          *_-_*->** escribe el ~valor~ en ~this.y~_--_
        _-_(puedes acceder al ~latch~ con ~this.ppu.registers.ppuAddr.latch~)_--_
        *_-_*->** cambia el ~latch~ al valor opuesto_--_
  responses:
  - bien, Â¿y despuÃ©s quÃ©? [then]

then:
  messages:
  - tendrÃ¡s en ~ppuScroll.x~ y ~ppuScroll.y~ las coordenadas de desplazamiento
  - Â¡ahora puedes aplicar el scrolling a los fondos!
  - |-
    ğŸ“š  _-_ve a `BackgroundRenderer` y cambia `renderScanline()`:
      *_-_*->** si antes tenÃ­as algo como...
        ```javascript
          for (let x = 0; x < 256; x += 8)```
      ...reemplÃ¡zalo con...
        ```javascript
          for (let x = 0; x < 256;)```
      ya no dibujarÃ¡s en bloques de 8 pÃ­xeles, debes estar preparado para dibujar solo una parte de ciertos tiles_--_
  - |-
    ğŸ“š  _-_definamos algunas cosas:
      ```javascript
      // coordenadas de scrolling:
      const scrollX = this.ppu.registers.ppuScroll.x;
      const scrollY = registers.ppuScroll.y;
      // punto actual para dibujar:
      const scrolledX = x + scrollX;
      const scrolledY = y + scrollY;
      // direcciÃ³n de la name table base:
      const nameTableId = this.ppu.registers.ppuCtrl.nameTableId;
      const scrolledNameTableId = nameTableId + Math.floor(scrolledX / 256) + Math.floor(scrolledY / 240) * 2;
      const nameTableAddress = 0x2000 + scrolledNameTableId * 1024;
      // punto actual, relativo a la name table:
      const nameTableX = scrolledX % 256;
      const nameTableY = scrolledY % 240;```
    
    a partir de ahora, cada uso de ~x~ y ~y~ deberÃ­a ser reemplazado por ~nameTableX~ y ~nameTableY~
    (por ejemplo: el Ã­ndice de lectura de la name table, la llamada `this._getBackgroundPaletteId(...)` y `new Tile(...)` deben ser actualizados)
    la Ãºnica excepciÃ³n es la llamada `plotBG`, que aÃºn necesita trazarse en el punto ~(x,y)~ de la pantalla_--_
  - |-
    ğŸ“š  _-_finalmente, define:
      ```javascript
      const tileStartX = nameTableX % 8;
      const tileStartY = nameTableY % 8;
      const tilePixels = Math.min(
        8 - tileStartX,
        256 - nameTableX
      );```
    
    recuerda, ya no dibujarÃ¡s 8 pÃ­xeles por iteraciÃ³n de bucle, solo dibujarÃ¡s `tilePixels`
    asÃ­ que, asegÃºrate de cambiar el bucle interno a algo como:
      ```javascript
        for (let xx = 0; xx < tilePixels; xx++)```
    y al final, incrementa manualmente el Ã­ndice del bucle principal:
      ```javascript
        x += tilePixels;```_--_
  responses: []
