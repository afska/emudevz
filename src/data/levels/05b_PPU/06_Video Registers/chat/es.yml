---
main:
  messages:
  - la ğŸ§   CPU y ğŸ–¥ï¸  PPU se comunican entre ellas a travÃ©s de un conjunto de 9 registros mapeados en memoria
  - estos viven en las direcciones CPU $2000-$2007 y $4014
  - echa un vistazo a ğŸ“„  ~/docs/ppu/video_registers.es.md~
  - algunos de ellos son ğŸ”  <solo lectura> (leÃ­dos por ğŸ§   CPU, escritos por ğŸ–¥ï¸  PPU)
  - algunos son âœï¸  <solo escritura> (leÃ­dos por ğŸ–¥ï¸  PPU, escritos por ğŸ§   CPU)
  - y algunos son <bidireccionales> ğŸ”  âœï¸
  responses:
  - dame un ejemplo ğŸ™ [example]
  - <<level.isCompleted || m.$exercise>> ğŸ“š  llÃ©vame a la acciÃ³n [useit]

example:
  messages:
  - hay dos ğŸ•Šï¸ ğŸ“–  pattern tables, Â¿recuerdas?
  - bueno, el cÃ³digo de un juego debe decirle al PPU cuÃ¡l deberÃ­a usar
  - para fondos, esto es controlado por el bit 4 de $2000 (ğŸ›ï¸  PPUCtrl)
  - lo llamamos ~B~ en nuestra columna ~Bits~
  - entonces, por ejemplo, si un juego quiere usar la segunda tabla, escribirÃ­a un 16 (binario ```raw 000```~1~```raw 0000```) en $2000
  - Â¡o cualquier nÃºmero que tenga el bit 4 encendido!
  - una escritura en $2000 afecta 6 parÃ¡metros al mismo tiempo (~V~, ~H~, ~B~, ~S~, ~I~, y ~NN~)
  - <{PPUCtrl.png}>
  responses:
  - Â¿entonces, estos registros solo contienen nÃºmeros? ğŸ”¢ [numbers]

numbers:
  messages:
  - sÃ­, pero algunos producen <efectos especiales> cuando la ğŸ§   CPU los lee o escribe
  - estos efectos secundarios pueden reiniciar un buffer interno, incrementar contadores, Â¡o incluso copiar datos!
  - "he programado una clase que te ayudarÃ¡ a implementar esto, deberÃ­as usarla ğŸ“–"
  - ğŸ“„  ~/lib/InMemoryRegister.js~
  responses:
  - Â¿cÃ³mo puedo usarla? [useit]

useit:
  run: |
    set((m) => m.$exercise = true);
  messages:
  - abre ğŸ“„  ~/tmpl/ppu/VideoRegisters.js~ y Ãºsalo como plantilla
  - los registros ğŸ›ï¸  `PPUCtrl` y ğŸ“Š  `PPUStatus` ya estÃ¡n implementados
  - observa cÃ³mo llaman a `addField(...)` por cada parÃ¡metro definido en la columna ~Bits~ del archivo de documentaciÃ³n, indicando el bit de inicio y su tamaÃ±o (cuando son mayores a 1 bit)
  - "esto crea <propiedades mÃ¡gicas>: despuÃ©s de la llamada a `onWrite(...)`, la PPU podrÃ¡ acceder a sus valores (p.ej. ```javascript ppuCtrl.spriteSize```)"
  - en el caso de ğŸ“Š  `PPUStatus`, usa `addWritableField(...)` porque la PPU necesita escribirlos (p. ej. ```javascript ppuStatus.isInVBlankInterval = 1```) para que la CPU pueda leer los valores actualizados mediante `onRead()`
  - ğŸ“š  crea una clase `VideoRegisters`, utilizando esa plantilla
  - |-
    ğŸ“š  agrega una propiedad `registers` a ğŸ–¥ï¸  `PPU`, asignada a:
         ```javascript new VideoRegisters(this)```
  - "ğŸ“š  finalmente, mapÃ©alos en ğŸ  `CPUMemory` (regiones $2000-$2007 y $4014):"
  - las <lecturas> deberÃ­an retornar ```javascript this.ppu.registers.read(address)```
  - las <escrituras> deberÃ­an llamar a ```javascript this.ppu.registers.write(address, value)``` y retornar
  responses: []
