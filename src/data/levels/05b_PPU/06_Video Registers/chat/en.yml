---
main:
  messages:
  - the ğŸ§   CPU and ğŸ–¥ï¸  PPU talk with each other via a set of 9 <memory-mapped registers>
  - these registers live in CPU addresses $2000-$2007 and $4014
  - check out ğŸ“„  ~/docs/ppu/video_registers.en.md~
  - some of them are ğŸ”  read-only (read by ğŸ§   CPU, written by ğŸ–¥ï¸  PPU) 
  - some are âœï¸  write-only (read by ğŸ–¥ï¸  PPU, written by ğŸ§   CPU)
  - and a few are bidirectional  ğŸ” âœï¸
  responses:
  - give me an example ğŸ™ [example]
  - <<level.isCompleted || m.$exercise>> ğŸ“š  take me to the action [useit]

example:
  messages:
  - there are two ğŸ•Šï¸ ğŸ“–  pattern tables, remember?
  - well, a game's code need to tell the PPU which one it should use
  - for backgrounds, this is handled by bit 4 of $2000 (ğŸ›ï¸  PPUCtrl)
  - we call it ~B~ in our ~Bits~ column
  - so, for example, if a game wants to use the second table, it would write a 16 (binary ```raw 000```~1~```raw 0000```) to $2000
  - or any number that has bit 4 set!
  - a write to $2000 affects 6 parameters at the same time (~V~, ~H~, ~B~, ~S~, ~I~, and ~NN~)
  - so, writing that 16 would also set the other 5 parameters to 0
  responses:
  - so, these registers only hold numbers? ğŸ”¢ [numbers]

numbers:
  messages: 
  - yes, but some produce <special effects> when the ğŸ§   CPU reads or writes them
  - these side effects can reset an internal buffer, increment counters, or even copying data!
  - "I've coded a class that will help you implement this, feel free to use it ğŸ“–"
  - ğŸ“„  ~/lib/InMemoryRegister.js~
  responses:
  - how can I use it? [useit]

useit:
  run: |
    set((m) => m.$exercise = true);
  messages:
  - have a look at ğŸ“„  ~/tmpl/ppu/VideoRegisters.js~ and use it as a template
  - registers ğŸ›ï¸  `PPUCtrl` and ğŸ“Š  `PPUStatus` are already implemented
  - note how they call `addField` for each parameter defined in the ~Bits~ column of the doc file, indicating the starting bit, and its size (when they're larger than 1 bit)
  - "this creates <magic properties>: after the `onWrite(...)` call, the PPU will be able to access their values (e.g. `ppuCtrl.spriteSize`)"
  - in the case of ğŸ“Š  `PPUStatus`, it uses `addWritableField` because the PPU needs to write them (e.g. `ppuStatus.isInVBlankInterval = 1`) so the CPU can read the updated values via `onRead()`
  - ğŸ“š  _-_create a `VideoRegisters` class, using that template_--_
  - |-
    _-_add a `registers` property to `PPU`, assigned to:_--_
         _-_```javascript new VideoRegisters(this)```_--_
  - _-_lastly, map them in `CPUMemory`:_--_
  - _-_<reads> should return ~this.ppu.registers.read(address)~_--_
  - _-_<writes> should call ~this.ppu.registers.write(address, value)~ and return_--_
  responses: []
