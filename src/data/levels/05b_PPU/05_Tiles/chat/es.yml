---
main:
  messages:
  - ok, vamos a dibujar tiles
  - lee ğŸ“„  ~/docs/ppu/tile_rendering.es.md~
  - deberÃ­a explicar cÃ³mo los tiles estÃ¡n codificados en memoria
  - vamos a crear una clase para ayudarnos a recuperar los colores de los tiles
  - dado que la PPU renderiza por ğŸŒ   scanlines, recibirÃ¡ un parÃ¡metro (`y`) que representa el Ã­ndice de la fila que debe dibujar
  - |-
    ğŸ“š  crea una clase ğŸ•Šï¸  `Tile` con lo siguiente:
    **constructor(ppu, patternTableId, tileId, y)**:
      **->** calcula la direcciÃ³n inicial de la pattern table:
        $0000 o $1000 dependiendo de `patternTableId` (~0~ o ~1~)
        (llamemos a esto `tableAddress`)
      **->** calcula la direcciÃ³n inicial del ğŸ’œ  low plane:
        ```javascript tableAddress + tileId * 16```
        (llamemos a esto `lowPlaneAddress`)
      **->** calcula la direcciÃ³n inicial del ğŸ’š  high plane:
        ```javascript lowPlaneAddress + 8```
        (llamemos a esto `highPlaneAddress`)
      **->** lee la fila correcta de cada bitplane:
        ```javascript this._lowRow``` = leer direcciÃ³n PPU ```javascript lowPlaneAddress + y```
        ```javascript this._highRow``` = leer direcciÃ³n PPU ```javascript highPlaneAddress + y```
    **getColorIndex(x)**:
      **->** determina la posiciÃ³n del bit que corresponde a `x` (un nÃºmero entre 0 y 7)
        ten en cuenta que ~x=0~ es el pÃ­xel mÃ¡s a la izquierda, y eso serÃ­a ~bit 7~
      **->** toma ese bit de ```javascript this._lowRow``` y ```javascript this._highRow``` usando `byte.getBit(...)`
      **->** devuelve el Ã­ndice de color resultante, combinando los dos bits con `byte.buildU2(...)`
  responses:
  - Â¿cÃ³mo lo probaremos? ğŸ§ [test]

test:
  messages:
  - Â¡buena pregunta! ğŸ˜
  - |+
    ğŸ“š  en tu ğŸ–¥ï¸  `PPU`, importa la clase ğŸ•Šï¸  `Tile` y reemplaza el cÃ³digo de prueba (antes de la llamada `onFrame`) con:

      ```javascript
      // <test>
      const testPalette = [0xffffffff, 0xff999999, 0xff424242, 0xff000000];
      const scale = 2;
      
      for (let tileId = 0; tileId < 240; tileId++) {
        const scaledSize = 8 * scale;
        const tilesPerRow = 256 / scaledSize;
        const startX = (tileId % tilesPerRow) * scaledSize;
        const startY = Math.floor(tileId / tilesPerRow) * scaledSize;
        
        for (let y = 0; y < 8; y++) {
          const tile = new Tile(this, 0, tileId, y);
          
          for (let x = 0; x < 8; x++) {
            const color = testPalette[tile.getColorIndex(x)];
            
            for (let scaledY = 0; scaledY < scale; scaledY++) {
              for (let scaledX = 0; scaledX < scale; scaledX++) {
                this.plot(
                  startX + x * scale + scaledX, 
                  startY + y * scale + scaledY, 
                  color
                );
              }
            }
          }
        }
      }
      // </test>```
  - esto dibujarÃ¡ los primeros 240 tiles de ğŸ‘¾  CHR-ROM
  - con una escala de ~2x~ (tiles de ~16x16~ en lugar de ~8x8~)
  - âš ï¸  funcionarÃ¡ <solo> en juegos que utilicen ğŸ‘¾  CHR-ROM âš ï¸
  responses:
  - Â¿quÃ© pasa con los juegos que usan ğŸ‘¾  CHR-RAM? [chrram]

chrram:
  messages:
  - esos juegos cargan tiles dinÃ¡micamente a travÃ©s del cÃ³digo del juego ğŸ¤–
  - y actualmente, la ğŸ§   CPU no tiene <ninguna forma> de escribir en nuestra ğŸ–¥ï¸  memoria PPU
  - por lo que en esos casos, solo verÃ¡s una pantalla en blanco
  responses: []
