---
main:
  messages:
  - ok, vamos a dibujar tiles
  - lee ğŸ“„  ~/docs/ppu/tile_rendering.es.md~
  - deberÃ­a explicar cÃ³mo los tiles estÃ¡n codificados en memoria
  - vamos a crear una clase para ayudarnos a recuperar los colores de los tiles
  - dado que la PPU renderiza por ğŸŒ   scanlines, recibirÃ¡ un parÃ¡metro (`y`) que representa el Ã­ndice de la fila que debe dibujar
  - |-
    ğŸ“š  _-_crea una clase `Tile` con lo siguiente:_--_
    *_-_*constructor(ppu, patternTableId, tileId, y)**:_--_
      *_-_*->** calcula la direcciÃ³n inicial de la pattern table:_--_
        _-_$0000 o $1000 dependiendo de ~patternTableId~ (~0~ o ~1~)_--_
        _-_(llamemos a esto ~tableAddress~)_--_
      *_-_*->** calcula la direcciÃ³n inicial del _--_ğŸ’œ _-_ low plane:_--_
        _-_~tableAddress + tileId * 16~_--_
        _-_(llamemos a esto ~lowPlaneAddress~)_--_
      *_-_*->** calcula la direcciÃ³n inicial del _--_ğŸ’š _-_ high plane:_--_
        _-_~lowPlaneAddress + 8~_--_
        _-_(llamemos a esto ~highPlaneAddress~)_--_
      *_-_*->** lee la fila correcta de cada bitplane:_--_
        _-_~this._lowRow~ = leer direcciÃ³n PPU ~lowPlaneAddress + y~_--_
        _-_~this._highRow~ = leer direcciÃ³n PPU ~highPlaneAddress + y~_--_
    *_-_*getColorIndex(x)**:_--_
      *_-_*->** determina la posiciÃ³n del bit que corresponde a ~x~ (un nÃºmero entre 0 y 7)_--_
        _-_ten en cuenta que ~x=0~ es el pÃ­xel mÃ¡s a la izquierda, y eso serÃ­a ~bit 7~_--_
      *_-_*->** toma ese bit de ~this._lowRow~ y ~this._highRow~ usando `byte.getBit(...)`_--_
      *_-_*->** devuelve el Ã­ndice de color resultante, combinando los dos bits con `byte.buildU2(...)`_--_
  responses:
  - Â¿cÃ³mo lo probaremos? ğŸ§ [test]

test:
  messages:
  - Â¡buena pregunta! ğŸ˜
  - |+
    _-_en tu `PPU`, reemplaza el cÃ³digo de prueba (antes de la llamada `onFrame`) con:

    ```javascript
    // <test>
    const testPalette = [0xffffffff, 0xff999999, 0xff424242, 0xff000000];
    const scale = 2;
    
    for (let tileId = 0; tileId < 240; tileId++) {
      const scaledSize = 8 * scale;
      const tilesPerRow = 256 / scaledSize;
      const startX = (tileId % tilesPerRow) * scaledSize;
      const startY = Math.floor(tileId / tilesPerRow) * scaledSize;
      
      for (let y = 0; y < 8; y++) {
        const tile = new Tile(this, 0, tileId, y);
        
        for (let x = 0; x < 8; x++) {
          const color = testPalette[tile.getColorIndex(x)];
          
          for (let scaledY = 0; scaledY < scale; scaledY++) {
            for (let scaledX = 0; scaledX < scale; scaledX++) {
              this.plot(
                startX + x * scale + scaledX, 
                startY + y * scale + scaledY, 
                color
              );
            }
          }
        }
      }
    }
    // </test>```_--_
  - esto dibujarÃ¡ los primeros 240 tiles de ğŸ‘¾  <CHR-ROM>
  - con una escala de ~2x~ (tiles de ~16x16~ en lugar de ~8x8~)
  - âš ï¸  funcionarÃ¡ <solo> en juegos que utilicen ğŸ‘¾  <CHR-ROM> âš ï¸
  responses:
  - Â¿quÃ© pasa con los juegos que usan ğŸ‘¾  <CHR-RAM>? [chrram]

chrram:
  messages:
  - esos juegos cargan tiles dinÃ¡micamente a travÃ©s del cÃ³digo del juego ğŸ¤–
  - y actualmente, la ğŸ§   CPU no tiene <ninguna forma> de escribir en nuestra ğŸ–¥ï¸  memoria PPU
  responses: []
