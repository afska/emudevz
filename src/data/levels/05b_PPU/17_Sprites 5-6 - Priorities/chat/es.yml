main:
  messages:
  - como vimos en la evaluaciÃ³n de sprites, los sprites con Ã­ndices OAM mÃ¡s bajos se dibujan al <frente>
  - ademÃ¡s, estÃ¡ el bit de prioridad <sprite-to-background> (byte 2, bit 5), que hace que los sprites aparezcan <detrÃ¡s> del fondo
  - cuando el fondo cubre un sprite, solo se toman en cuenta los pÃ­xeles opacos
  responses:
  - muÃ©strame un ejemplo [example]

example:
  run: |
    {{Top}}.loadROM("/roms/.all/SuperTiltBro.neees");
  messages:
  - presta atenciÃ³n a la <nube> en el medio
  - la nube es un sprite y el tÃ­tulo del juego es parte del fondo
  - llegado a un punto, cubre las palabras "TILT" y "BRO", cuando deberÃ­a estar detrÃ¡s de ellas
  - esto es porque no estamos usando las prioridades correctas de los sprites
  - y BrokenNEEES tambiÃ©n lo hizo mal, Â¡asÃ­ que no importa quÃ© PPU uses!
  responses:
  - Â¿cÃ³mo podemos arreglarlo? [fix]

fix:
  messages:
  - primero, necesitamos recordar quÃ© pÃ­xeles del fondo son transparentes
  - es decir, cuando el Ã­ndice de color es 0
  - luego, guardaremos los colores y sprites de la scanline actual en un buffer temporal
  - y solo dibujaremos los pÃ­xeles de ese buffer si la prioridad del sprite es <front> o si el pÃ­xel del fondo es transparente
  responses:
  - suena bastante claro [exercise]

exercise:
  messages:
  - |-
    ğŸ“š  de acuerdo, en la clase ğŸ–¥ï¸  `PPU`, agrega al constructor:
      ```javascript
      this.colorIndexes = new Uint8Array(256*240);```
  - |-
    ğŸ“š  implementa estos mÃ©todos:
    **plotBG(x, y, color, colorIndex)**:
      **->** guarda el `colorIndex`:
        ```javascript this.colorIndexes[y * 256 + x] = colorIndex;```
      **->** dibuja el pÃ­xel:
        ```javascript this.plot(x, y, color);```
    **isBackgroundPixelOpaque(x, y)**:
      **->** retorna si el pÃ­xel ~(x, y)~ en `colorIndexes` es mayor que 0 o no
  - ğŸ“š  en ğŸï¸  `BackgroundRenderer`, en lugar de llamar al mÃ©todo `plot(...)`, llama a `plotBG(...)` pasando el `colorIndex` como Ãºltimo argumento
  - |-
    ğŸ“š  en ğŸ›¸  `SpriteRenderer`, <modifica> estos mÃ©todos:
      **_render(...)**:
        **->** al inicio, declara un `buffer` como un array vacÃ­o
        **->** en lugar de llamar a ```javascript this.ppu.plot(...)```, guarda la informaciÃ³n en el `buffer`:
          ```javascript const x = sprite.x + insideX;```
          ```javascript const color = paletteColors[colorIndex];```
          ```javascript buffer[x] = { x, sprite, color };```
        **->** al final, ```javascript return buffer;```
      **renderScanline()**:
        **->** asigna el valor devuelto por ```javascript this._render(sprites)``` a una constante `buffer`
        **->** llama a ```javascript this._draw(buffer);```
  - |-
    ğŸ“š  y define:
      **_draw(buffer)**:
        **->** determina la coordenada y:
          ```javascript this.ppu.scanline;```
          (llamemos a esto `y`)
        **->** para cada `element` en el array `buffer`:
          **->** si el `element` no es ```javascript undefined```:
            **->** determina si el sprite estÃ¡ al frente del fondo:
              ```javascript element.sprite.isInFrontOfBackground;```
              (llamemos a esto `isInFront`)
            **->** determina si el pÃ­xel correspondiente del fondo es opaco:
              ```javascript this.ppu.isBackgroundPixelOpaque(element.x, y);```
              (llamemos a esto `isBGOpaque`)
            **->** si ```javascript isInFront || !isBGOpaque```:
              **->** llama a ```javascript this.ppu.plot(element.x, y, element.color);```
  responses: []

corollary:
  messages:
  - si ejecutas ğŸ¦¸ ğŸ¤¸  ~Super Tilt Bro~, verÃ¡s que ahora las nubes se renderizan correctamente ğŸ™‚
  responses:
  - â–¶ï¸  continuar [end]
