main:
  messages:
  - el scrolling es una caracterÃ­stica de la PPU que permite a los desarrolladores mover el fondo
  - implementarlo en un emulador NEEES es difÃ­cil ğŸ¥µ
  - no porque sea difÃ­cil mover el fondo, sino porque los registros de desplazamiento se comportan de maneras no obvias
  - mucha gente lo ha intentado, pero solo los elegidos pudieron lograrlo
  responses:
  - Â¿tienes un plan? [plan]

plan:
  messages:
  - sÃ­, podemos hacerlo juntos
  - intentarÃ© ayudarte al abstraer las partes complicadas en una biblioteca
  - tomarÃ¡ un tiempo
  - mientras tanto, puedes agregar una implementaciÃ³n bÃ¡sica del scrolling que no funcionarÃ¡ para todos los juegos
  - Â¡pero serÃ¡ suficiente para la mayorÃ­a de ellos!
  responses:
  - suena bien, Â¿cÃ³mo funciona el scrolling? [good]

good:
  run: |
    {{Top}}.load("scrolling.gif");
  messages:
  - bueno, los juegos en realidad no mueven <el fondo>
  - mueven una ventana imaginaria contra el fondo estÃ¡tico
  - eso es suficiente para crear la idea de movimiento ğŸŒ€
  responses:
  - Â¿y cÃ³mo se mueve la ventana? [viewport]

viewport:
  messages:
  - asÃ­
  - <{3rdparty_nametable_scrolling.png}>
  - los juegos escriben en ğŸ“œ  PPUScroll la posiciÃ³n de la ventana
  - escriben dos veces, primero para la <coordenada X>, luego para la <coordenada Y>
  - y la PPU mueve la ventana, dibujando solo parte de las name tables afectadas
  responses:
  - entonces... si los juegos escriben dos veces, la PPU tiene que recordar quÃ© coordenada estÃ¡n configurando, Â¿cierto? [twice]

twice:
  messages:
  - exacto
  - Â¿recuerdas cÃ³mo funciona ğŸ“  `PPUAddr`? Â¿con un `latch` que cambia despuÃ©s de cada escritura?
  - bueno, asÃ­
  - Â¡de hecho, usa ese mismo `latch`!
  responses:
  - entiendo... [isee]

isee:
  messages:
  - los primeros juegos de NEEES solo se desplazaban en una direcciÃ³n
  - los juegos con <mirroring horizontal> de name tables solo se desplazaban <verticalmente>
  - y los juegos con <mirroring vertical> de name tables solo se desplazaban <horizontalmente>
  - <{3rdparty_vertical_horizontal.png}>
  responses:
  - no entiendo, si solo hay dos name tables fÃ­sicas, Â¿cÃ³mo logran los juegos tener mapas largos? [long]

long:
  messages:
  - actualizan partes del fondo progresivamente cuando la ventana no estÃ¡ enfocada en ellas
  - por cierto, la posiciÃ³n de la ventana se basa en la <name table base>
  - recuerda que los primeros dos bits de ğŸ›ï¸  `PPUCtrl` seleccionan la name table actual
  - (tienes eso mapeado como `registers.ppuCtrl.nameTableId`)
  - asÃ­ que, si la name table base es 1, significa que la ventana deberÃ­a comenzar en la name table posicionada en $2400
  - <{3rdparty_scrolled_nametables.png}>
  responses:
  - suficiente charla, Â¿cÃ³mo procedemos? [exercise]

exercise:
  run: |
    {{Top}}.load(null, "rom");
  messages:
  - (de nuevo, ~ESTO NO ES EXACTAMENTE CORRECTO~, Â¡pero funcionarÃ¡ por ahora!)
  - |-
    ğŸ“š  implementa estos mÃ©todos de ğŸ“œ  `PPUScroll`:
      **onLoad()**:
        **->** asigna ```javascript this.x = 0```
        **->** asigna ```javascript this.y = 0```
      **onWrite(value)**:
        **->** si el `latch` de ğŸ“  PPUAddr es ```javascript false```:
          **->** escribe el `valor` en ```javascript this.x```
        **->** si es ```javascript true```:
          **->** escribe el `valor` en ```javascript this.y```
        (puedes acceder al `latch` con ```javascript this.ppu.registers.ppuAddr.latch```)
        **->** cambia el `latch` al valor opuesto
  responses:
  - bien, Â¿y despuÃ©s quÃ©? [then]

then:
  messages:
  - tendrÃ¡s en ```javascript ppuScroll.x``` y ```javascript ppuScroll.y``` las coordenadas de desplazamiento
  - Â¡ahora puedes aplicar el scrolling a los fondos!
  - |-
    ğŸ“š  ve a ğŸï¸  `BackgroundRenderer` y <cambia> `renderScanline()`:
      **->** si antes tenÃ­as algo como...
        ```javascript
          for (let x = 0; x < 256; x += 8)```
      ...reemplÃ¡zalo con...
        ```javascript
          for (let x = 0; x < 256;)```
      ya no dibujarÃ¡s en bloques de 8 pÃ­xeles, debes estar preparado para dibujar solo una parte de ciertos tiles
  - |-
    ğŸ“š  definamos algunas cosas:
      ```javascript
      // coordenadas de scrolling:
      const scrollX = this.ppu.registers.ppuScroll.x;
      const scrollY = this.ppu.registers.ppuScroll.y;
      // punto actual a dibujar:
      const scrolledX = x + scrollX;
      const scrolledY = y + scrollY;
      // direcciÃ³n de la name table base:
      const nameTableId = (
        this.ppu.registers.ppuCtrl.nameTableId +
        (scrolledX >= 256 ? 1 : 0) + // mover a la derecha
        (scrolledY >= 240 ? 2 : 0) // mover abajo
      ) % 4;
      const nameTableAddress = 0x2000 + nameTableId * 1024;
      // punto actual, relativo a la name table:
      const nameTableX = scrolledX % 256;
      const nameTableY = scrolledY % 240;```
    
  - |-
    ğŸ“š  a partir de ahora, cada uso de `x` y `y` deberÃ­a ser reemplazado por `nameTableX` y `nameTableY`
      (por ejemplo: el Ã­ndice de lectura de la name table, la llamada ```javascript this._getBackgroundPaletteId(...)``` y ```javascript new Tile(...)``` deben ser actualizados)
  - la Ãºnica excepciÃ³n es la llamada `plotBG(...)`, que aÃºn necesita trazarse en el punto ~(x,y)~ de la pantalla
  - |-
    ğŸ“š  finalmente, define:
      ```javascript
      const tileStartX = nameTableX % 8;
      const tileInsideY = nameTableY % 8;
      const tilePixels = Math.min(
        8 - tileStartX,
        256 - nameTableX
      );```
  - recuerda, ya no dibujarÃ¡s 8 pÃ­xeles por iteraciÃ³n de bucle, solo dibujarÃ¡s `tilePixels`, empezando desde `tileStartX`
  - |-
    ğŸ“š  asÃ­ que, asegÃºrate de cambiar el bucle interno a algo como:
      ```javascript
        for (let xx = 0; xx < tilePixels; xx++)```
    la llamada a `getColorIndex(...)` tendrÃ­a que usar `tileStartX`:
      ```javascript
        tile.getColorIndex(tileStartX + xx);```
    y al final, una vez que el bucle interno termine, incrementa manualmente el Ã­ndice del bucle principal:
      ```javascript
        x += tilePixels;```
  responses: []

corollary:
  messages:
  - esto deberÃ­a ser suficiente para tener scrolling en la mayorÃ­a de los juegos
  - excepto por ese maldito <plumber game>, que se colgarÃ¡ tan solo despuÃ©s de correr unos pocos metros ğŸ¤¦
  - pero ignoremos eso por ahora
  - prueba... quizÃ¡s la demo de ğŸŒŒ ğŸ”«  ~Isostasy~ o ğŸº ğŸŒ²  ~Wolf Spirit~
  responses:
  - â–¶ï¸  continuar [end]
