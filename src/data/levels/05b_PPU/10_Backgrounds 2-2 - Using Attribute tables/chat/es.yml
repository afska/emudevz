---
main:
  messages:
  - para permitir colores, primero necesitamos permitir que los juegos escriban informaciÃ³n de color
  - en otras palabras, necesitamos mapear ğŸ  Palette RAM en nuestra memoria PPU
  - luego, agregaremos mÃ©todos para leer paletas de colores
  - y finalmente, haremos que `BackgroundRenderer` use paletas para renderizar
  - ğŸ“š  como hiciste con `PPUMemory::vram`, agrega una propiedad llamada `paletteRam` en `PPUMemory`
  - el array deberÃ­a almacenar 32 bytes
  - ğŸ“š  mapea el rango $3F00-$3F1F a Palette RAM (tanto lecturas como escrituras)
  - |-
    ğŸ“š  implementa este mÃ©todo en `PPU`:
    **getColor(paletteId, colorIndex)**:
      **->** calcula la direcciÃ³n inicial de la paleta:
        `0x3F00 + paletteId * 4`
        (llamemos a esto `startAddress`)
      **->** lee el Ã­ndice de color de la memoria:
        lee desde la direcciÃ³n PPU ```javascript startAddress + colorIndex```
        (llamemos a esto `masterColorIndex`)
      **->** devuelve un color de la paleta maestra, usando `masterColorIndex`
        (puedes importar y usar ğŸ“„  ~/lib/ppu/masterPalette.js~ para la lista de colores)
  - |-
    ğŸ“š  implementa este mÃ©todo en `BackgroundRenderer`:
    **_getPaletteId(nameTableId, x, y)**:
      **->** agrega el cÃ³digo necesario para devolver el id de paleta correcto para el pÃ­xel ~(x, y)~
      **->** sigue ğŸ“„  ~/docs/ppu/background_rendering.es.md~ para orientaciÃ³n sobre cÃ³mo se codifican los ids de paletas
  - |-
    ğŸ“š  cambia `BackgroundRenderer::renderScanline()` para que use `_getPaletteId(...)` y dibuje el color correcto, asÃ­:
      ```javascript
      const paletteId = this._getBackgroundPaletteId(nameTableId, x, y);

      const tileInsideY = y % 8;

      const tile = new Tile(this, patternTableId, tileId, tileInsideY);
      for (let xx = 0; xx < 8; xx++) {
        const colorIndex = tile.getColorIndex(xx);
        const color =
          colorIndex > 0 ? this.ppu.getColor(paletteId, colorIndex) : this.ppu.getColor(0, 0);
        this.plot(x + xx, y, color);
      }```
  - ten en cuenta que cuando el Ã­ndice de color es 0, se renderiza un <color de fondo> en su lugar (ubicado en el primer Ã­ndice de la primera paleta)
  responses:
  - "\"Â¿agrega el cÃ³digo necesario\"? Â¿en serio? Â¿eso es todo? [help]"

help:
  messages:
  - Â¿quÃ©, necesitas ayuda? ğŸ¤£
  - bueno... estoy escuchando
  responses:
  - ayÃºdame con las matemÃ¡ticas ğŸ”¢ [math]
  - Â¿cuÃ¡l es el color de fondo? ğŸ’§ [backdrop]

math:
  messages:
  - ğŸ”  primero, basado en el punto ~(x, y)~, necesitas saber en quÃ© <metabloque> estÃ¡s
  - un <metabloque> es ~2x2 bloques~, ~4x4~ tiles, o ~32x32~ pÃ­xeles (como quieras verlo)
  - asÃ­ que ```javascript Math.floor(x / 32)``` y ```javascript Math.floor(y / 32)``` te darÃ¡n nÃºmeros que puedes llamar `metablockX` y `metablockY`
  - ya que esto es una matriz, para calcular el `metablockIndex` puedes hacer ```javascript metablockY * 8 + metablockX```
  - (multiplicamos por 8 porque hay 8 metabloques por fila)
  - |-
    ğŸ“–  con este `metablockIndex`, puedes leer el `block`:
      ```javascript this.ppu.memory.read(startAddress + metablockIndex);```
  - (`startAddress` serÃ­a la direcciÃ³n inicial de la ğŸ–ï¸ ğŸ“–  attribute table, tambiÃ©n conocida como los Ãºltimos 64 bytes de la ğŸï¸ ğŸ“–  name table)
  - ğŸ”  con este `block`, basado en el punto ~(x, y)~, ahora necesitas saber en quÃ© <block> estÃ¡s
  - |-
    un <block> es ~2x2~ tiles o ~16x16~ pÃ­xeles, por lo tanto:
      ```javascript
      const blockX = Math.floor((x % 32) / 16);
      const blockY = Math.floor((y % 32) / 16);
      const blockIndex = blockY * 2 + blockX;```
  - ğŸ•µï¸  con este `blockIndex`, puedes tomar los bits requeridos de `block` usando `byte.getBits(...)`
  - (necesitas leer 2 bits, comenzando desde el bit `blockIndex * 2`)
  - Â¡y eso te darÃ¡ el `paletteId` de ese punto ~(x, y)~!
  responses:
  - uff [oof]

oof:
  messages:
  - sÃ­ii... la vida es dura ğŸ˜…
  - bueno, Â¡buena suerte!
  responses: []

backdrop:
  messages:
  - puedes pensar en ello como un color "transparente" global
  - el Ã­ndice 0 de cada paleta lo usarÃ¡, y estÃ¡ definido en ~paleta 0, Ã­ndice 0~ (tambiÃ©n conocido como ~PPU $3F00~)
  responses:
  - ...help
