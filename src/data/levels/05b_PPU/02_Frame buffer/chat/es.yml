---
main:
  run: |
    {{Top}}.load("frameBuffer.png");
  messages:
  - almacenaremos nuestros datos de imagen en algo llamado <frame buffer>
  - es b√°sicamente una gran matriz con el color de cada p√≠xel
  - cada elemento es un n√∫mero de 32 bits __$aabbggrr__
  - "\"aa\" representa la opacidad (en nuestra NEEES siempre es $FF)"
  - "\"bb\", \"gg\" and \"rr\" representan la cantidad de <azul>, <verde> y <rojo>"
  responses:
  - (*) ¬øpuedes darme algunos ejemplos de colores? [examples]
  - ¬°quiero dibujar algo en la pantalla! üñåÔ∏è [integrate]
  - <<level.isCompleted || m.$exercise>> üìö  ll√©vame a la acci√≥n [draw]

examples:
  messages:
  - "aqu√≠ tienes algunos colores de ejemplo:"
  - "‚ù§Ô∏è  ```javascript 0xFF0000FF``` = rojo"
  - "üíö  ```javascript 0xFF00FF00``` = verde"
  - "üíô  ```javascript 0xFFFF0000``` = azul"
  - "‚ö™  ```javascript 0xFFFFFFFF``` = blanco"
  - "üñ§  ```javascript 0xFF000000``` = negro"
  - "ü¶à  ```javascript 0xFF989898``` = gris"
  - "üíõ  ```javascript 0xFF00F8F8``` = amarillo"
  responses:
  - ...main

integrate:
  run: |
    {{Top}}.load(null, "rom");
  messages:
  - primero que nada, voy a integrar tu üñ•Ô∏è  PPU en el emulador
  - deber√≠a ser r√°pido...
  run-after-messages: |
    level.startEffect("earthquake");
    setTimeout(() => {
      bus.emit("patching-end");
    }, 500);
  events: 
  - patching-end [done]

done:
  run: |
    level.stopEffect();
    book.unlock("usePPU");
  messages:
  - ‚úîÔ∏è  ¬°listo!
  - ahora, el √≠cono üñ•Ô∏è  en el emulador brillar√° ‚ú®
  - como casi no hay c√≥digo PPU, por ahora no se mostrar√° nada
  - ¬°pero llegaremos all√≠!
  responses:
  - programemos esto ü§ü [draw]

draw:
  run: |
    set((m) => m.$exercise = true);
    {{Top}}.load(null, "rom");
  messages:
  - |-
    üìö  _-_ok, vamos a agregar esto al constructor de tu PPU:
      ```javascript
      this.frameBuffer = new Uint32Array(256*240);```_--_
  - |-
    _-_implementa este m√©todo:_--_
    **plot(x, y, color)**:
      **->** asigna el ~color~ al pixel ~(x,y)~ en el array ~frameBuffer~
        (el √≠ndice para ~(x,y)~ deber√≠a ser ~y * 256 + x~)
  - _-_luego, modifica tu m√©todo `step` para que reciba un callback `onFrame` como par√°metro_--_
  - |-
    _-_y cada vez que detectes un nuevo frame (justo despu√©s de ```javascript this.frame++;```), ll√°malo con el frame buffer, as√≠:
      ```javascript onFrame(this.frameBuffer);```_--_
  - |-
    para asegurarnos de que todo funciona correctamente, agrega este c√≥digo antes de la llamada a `onFrame`:
    ```javascript
    // <test>
    for (let x = 0; x < 256; x++) {
      for (let y = 0; y < 240; y++) {
        this.plot(x, y, 0xff000000 | this.frame % 0xff);
      }
    }
    // </test>```
  - _-_¬°pru√©balo! al iniciar una ROM, deber√≠a lentamente pintar la pantalla de rojo _--_üî¥
  responses: []
