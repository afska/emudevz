main:
  messages:
  - en cada scanline, el renderizador de sprites realiza una ~evaluaciÃ³n de sprites~ ğŸ•µï¸
  - prepara los sprites que necesitan ser renderizados
  responses:
  - mhm... Â¿cÃ³mo lo hace? [how]

how:
  messages:
  - escanea toda la tabla OAM, comprobando si cada sprite debe dibujarse en la scanline actual (basado en ~x~, ~y~, y ~height~)
  - elige los primeros 8 sprites
  - despuÃ©s de encontrar 8 (el nÃºmero mÃ¡ximo de sprites por scanline), si encuentra <mÃ¡s> sprites visibles, la ğŸ  ~bandera de sprite overflow~ (bit 5 de ğŸ“Š  ~PPUStatus~) se enciende para notificar el error al desarrollador del juego
  - los sprites con identificadores mÃ¡s bajos se renderizan encima de los sprites con identificadores mÃ¡s altos, Â¡asÃ­ que deberÃ­as invertir la lista de sprites elegidos!
  responses:
  - ok creo que lo entendÃ­ [ok]

ok:
  messages:
  - |-
    ğŸ“š  _-_genial, implementa el siguiente mÃ©todo en `SpriteRenderer`:_--_
    *_-_*_evaluate()**:_--_
      *_-_*->** define un array ~sprites~_--_
      *_-_*->** para cada id de sprite posible (~0-63~):_--_
        *_-_*->** crea un sprite usando ~this._createSprite(...)~_--_
        *_-_*->** si el sprite debe renderizarse en la scanline actual, y ~sprites~ tiene menos de 9 elementos:_--_
          *_-_*->** si ~sprites~ tiene menos de 8 elementos:_--_
            *_-_*->** aÃ±ade al arreglo ~sprites~_--_
          *_-_*->** de lo contrario:_--_
            *_-_*->** asigna ~this.ppu.registers.ppuStatus.spriteOverflow = 1~_--_
            *_-_*->** detiene el bucle_--_
      *_-_*->** devuelve ~sprites~ en orden inverso_--_
  - ğŸ“š _-_ademÃ¡s, necesitas reiniciar `spriteOverflow` a 0 en ~scanline=-1; cycle=1~, como lo hiciste anteriormente con ~isInVBlankInterval~_--_
  - ğŸ“š _-_hazlo en `PPU::_onPreLine(...)`_--_
  responses:
  - Â¿cÃ³mo sÃ© si un sprite debe ser renderizado? [visible]

visible:
  messages:
  - hay un mÃ©todo para verificar esto en mi biblioteca Sprite
  - usa ~sprite.shouldRenderInScanline(this.ppu.scanline)~
  responses: []
