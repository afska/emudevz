---
main:
  run: |
    {{Top}}.load("rendering.png");
  messages:
  - abrÃ³chate el cinturÃ³n, Â¡vamos a empezar a dibujar <pixels de verdad> en la pantalla! ğŸ–¥ï¸
  - pero primero necesitamos aprender algunas cosas
  - verÃ¡s... todo depende del timing â±ï¸
  - ğŸš²  ciclos, ğŸŒ   scanlines y ğŸ–¼ï¸  frames
  responses:
  - Â¿a quÃ© te refieres? [wdym]

wdym:
  messages:
  - ğŸ“ˆ  la NEEES genera una seÃ±al de video de 60FPS
  - ğŸ–¼ï¸  cada <frame> es una imagen de 256x240 (piensa en ello como una cuadrÃ­cula de pÃ­xeles)
  - ğŸŒ   una <scanline> serÃ­a una fila de esa cuadrÃ­cula
  - ğŸš²  ah, y cada scanline toma 341 <ciclos> de PPU para renderizar
  responses:
  - Â¿y... quÃ© es un ciclo? ğŸš² [cycles]

cycles:
  messages:
  - cada operaciÃ³n que hace la PPU toma cierta cantidad de tiempo, que medimos en <ciclos>
  - estos duran solo fracciones de segundo, Â¡y pasan varias cosas en un ciclo!
  - la PPU puede leer o escribir datos, o incluso dibujar un pixel en la pantalla ğŸ¨
  responses:
  - (*) Â¿los ciclos de PPU son los mismos que los ciclos de CPU? ğŸ¤” [same]
  - Â¿cÃ³mo funciona el dibujado? ğŸ–Œï¸ [drawing]

same:
  messages:
  - conceptualmente, sÃ­, pero la ğŸ–¥ï¸  PPU funciona 3 veces mÃ¡s rÃ¡pido que la ğŸ§   CPU
  - asÃ­ que los ciclos de PPU son mÃ¡s rÃ¡pidos (cada ciclo de PPU es, en tiempo, ~1/3~ de un ciclo de CPU)
  responses:
  - ...cycles

drawing:
  messages:
  - dibuja de arriba a abajo, una scanline a la vez, un pixel por ciclo
  - las primeras 240 scanlines conforman la parte visible de la imagen
  - tambiÃ©n hay algunas scanlines extras no visibles, lo que le da a la PPU algo de tiempo para descansar ğŸ–ï¸
  responses:
  - Â¿quÃ© quieres decir con "tiempo para descansar"? [vblank_hblank]

vblank_hblank:
  messages:
  - durante cada scanline (despuÃ©s de haber dibujado todos los pÃ­xeles), hay un pequeÃ±o descanso conocido como Horizontal Blank, o <HBlank>
  - y al final de todas las scanlines visibles, hay un descanso mÃ¡s largo, el Vertical Blank, o <VBlank> ğŸï¸
  - durante estos perÃ­odos, la PPU no estÃ¡ dibujando ningÃºn pixel, y eso da la oportunidad al programa de actualizar la pantalla
  responses:
  - entendido, Â¿quÃ© sigue? [next]

next:
  messages:
  - ğŸ“š  crea un archivo en algÃºn lugar para el cÃ³digo de la PPU
  - |-
    deberÃ­a exportar una clase asÃ­:
      ```javascript
      export default class PPU {
        constructor(cpu) {
          this.cpu = cpu;

          this.cycle = 0;
          this.scanline = -1;
          this.frame = 0;
        }
      }
      ```
  - |-
    y agrega este mÃ©todo (por ahora, solo mantendrÃ¡ un registro del tiempo):
      ```javascript
      step() {
        this.cycle++;
        if (this.cycle >= 341) {
          this.cycle = 0;
          this.scanline++;

          if (this.scanline >= 261) {
            this.scanline = -1;
            this.frame++;
          }
        }
      }
      ```
  - luego, importa ese archivo desde ğŸ“„  ~/code/index.js~
  - y agrega una clave `PPU` (que apunte a esa clase) al objeto exportado
  responses:
  - Â¿por quÃ© el contador de scanlines comienza en -1? ğŸ˜• [minus1]

minus1:
  messages:
  - la scanline ~-1~ (tambiÃ©n llamada <pre-line>) es una lÃ­nea no visible, en la que la PPU prepara las cosas para el prÃ³ximo frame
  - durante este tiempo, reinicia algunas banderas de estado importantes
  - Â¡mÃ¡s sobre esto despuÃ©s! ğŸ”œ
  responses: []
