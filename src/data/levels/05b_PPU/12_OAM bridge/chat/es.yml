main:
  messages:
  - los juegos tambiÃ©n definen, en tiempo de ejecuciÃ³n, cÃ³mo deben lucir los sprites ğŸ›¸
  - lo hacen escribiendo una tabla llamada OAM ("Object Attribute Memory")
  - esta tabla se encuentra en una regiÃ³n de memoria <interna> llamada ğŸ  OAM RAM
  responses:
  - Â¿cÃ³mo puede un juego escribir en ğŸ  OAM RAM? [how]

how:
  messages:
  - "hay dos maneras:"
  - "1) usando los registros ğŸ   OAMAddr y ğŸ“  OAMData"
  - "2) usando âš¡  OAMDMA"
  responses:
  - cuÃ©ntame sobre ğŸ   OAMAddr y ğŸ“  OAMData [addrdata]
  - cuÃ©ntame sobre âš¡  OAMDMA [dma]
  - implementemos ese puente [implement]

addrdata:
  messages:
  - no hay mucho que decir sobre ellos
  - es lo mismo que ğŸ“  PPUAddr y ğŸ“¦  PPUData
  - pero acceden a ğŸ  OAM RAM en lugar de la memoria PPU
  responses:
  - ...how

dma:
  messages:
  - DMA ("Direct Memory Access") es un mecanismo de hardware para copiar bytes de una regiÃ³n de memoria a otra muy rÃ¡pidamente
  - en el NEEES, esto se proporciona mediante el registro âš¡  OAMDMA, que permite a los juegos llenar ğŸ  OAM RAM copiando bytes de la memoria de la CPU
  - escribir ```raw $```~XX~ en ese registro copiarÃ¡ 256 bytes de las direcciones CPU ```raw $```~XX~```raw 00```-```raw $```~XX~```raw FF``` a la OAM RAM interna
  - esta operaciÃ³n tomarÃ¡ alrededor de 513 ciclos de CPU, durante los cuales la CPU estÃ¡ suspendida
  responses:
  - ...how

implement:
  messages:
  - ğŸ“š  como hiciste con `PPUMemory::vram`, agrega una propiedad llamada `oamRam` en `PPUMemory`
  - el array debe almacenar 256 bytes
  - esta vez, no tienes que mapearla, la OAM es muy <interna>
  - |-
    ğŸ“š  implementa estos mÃ©todos en `OAMData`:
    **onRead()**:
      **->** guarda la direcciÃ³n OAM actual:
        ```javascript const oamAddress = this.ppu.registers.oamAddr.value;```
        (el campo `value` estÃ¡ definido en `InMemoryRegister` y representa el valor actual)
      **->** devuelve el byte correspondiente de OAM RAM, usando `oamAddress`
    **onWrite(value)**:
      **->** guarda la direcciÃ³n OAM actual (`oamAddress`)
      **->** escribe `value` en el byte correspondiente de OAM RAM, usando `oamAddress`
      **->** incrementa la direcciÃ³n OAM:
        ```javascript this.ppu.registers.oamAddr.setValue(oamAddress + 1);```
  - |-
    ğŸ“š  implementa este mÃ©todo en `OAMDMA`:
    **onWrite(value)**:
      **->** ```javascript for (i = 0; i < 256; i++)```:
        **->** construye la direcciÃ³n (high byte: `value`, low byte: `i`)
        **->** lee la direcciÃ³n de la memoria de la CPU (```javascript this.ppu.cpu``` devuelve la `CPU`)
        **->** asigna el byte obtenido a ```javascript oamRam[i]```
      **->** suma 513 a ```javascript this.ppu.cpu.extraCycles```
  responses: []
