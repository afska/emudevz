main:
  messages:
  - los juegos tambiÃ©n definen, en tiempo de ejecuciÃ³n, cÃ³mo deben lucir los sprites ğŸ›¸
  - lo hacen escribiendo una tabla llamada <OAM> ("Object Attribute Memory")
  - esta tabla se encuentra en una regiÃ³n de memoria <interna> llamada ğŸ  OAM RAM
  responses:
  - Â¿cÃ³mo puede un juego escribir en ğŸ  OAM RAM? [how]

how:
  messages:
  - "hay dos maneras:"
  - "1) usando los registros ğŸ   ~OAMAddr~ y ğŸ“  ~OAMData~"
  - "2) usando âš¡  ~OAMDMA~"
  responses:
  - cuÃ©ntame sobre ğŸ   OAMAddr y ğŸ“  OAMData [addrdata]
  - cuÃ©ntame sobre âš¡  OAMDMA [dma]
  - implementemos ese puente [implement]

addrdata:
  messages:
  - no hay mucho que decir sobre ellos
  - es lo mismo que ğŸ“  ~PPUAddr~ y ğŸ“¦  ~PPUData~
  - pero acceden a ğŸ  OAM RAM en lugar de la memoria PPU
  responses:
  - ...how

dma:
  messages:
  - DMA ("Direct Memory Access") es un mecanismo de hardware para copiar bytes de una regiÃ³n de memoria a otra muy rÃ¡pidamente
  - en el NEEES, esto se proporciona mediante el registro âš¡  ~OAMDMA~, que permite a los juegos llenar ğŸ  OAM RAM copiando bytes de la memoria de la CPU
  - escribir ```raw $```~XX~ en ese registro copiarÃ¡ 256 bytes de las direcciones CPU ```raw $```~XX~```raw 00```-```raw $```~XX~```raw FF``` a la OAM RAM interna
  - esta operaciÃ³n tomarÃ¡ alrededor de 513 ciclos de CPU, durante los cuales la CPU estÃ¡ suspendida
  responses:
  - ...how

implement:
  messages:
  - ğŸ“š  _-_como hiciste con `PPUMemory::vram`, agrega una propiedad llamada `oamRam` en `PPUMemory`_--_
  - _-_el array debe almacenar 256 bytes_--_
  - _-_esta vez, no tienes que mapearla, la OAM es muy <interna>_--_
  - |-
    ğŸ“š  _-_implementa estos mÃ©todos en `OAMData`:_--_
    *_-_*onRead()**:_--_
      *_-_*->** guarda la direcciÃ³n OAM actual:_--_
        _-_```javascript const oamAddress = this.ppu.registers.oamAddr.value;```_--_
        _-_(el campo `value` estÃ¡ definido en `InMemoryRegister` y representa el valor actual)_--_
      *_-_*->** devuelve el byte correspondiente de OAM RAM, usando ~oamAddress~_--_
    *_-_*onWrite(value)**:_--_
      *_-_*->** guarda la direcciÃ³n OAM actual (~oamAddress~)_--_
      *_-_*->** escribe ~value~ en el byte correspondiente de OAM RAM, usando ~oamAddress~_--_
      *_-_*->** incrementa la direcciÃ³n OAM:_--_
        _-_```javascript this.ppu.registers.oamAddr.setValue(oamAddress + 1);```_--_
  - |-
    ğŸ“š  _-_implementa este mÃ©todo en `OAMDMA`:_--_
    *_-_*onWrite(value)**:_--_
      *_-_*->** ~for i = 0; i < 256; i++~:_--_
        *_-_*->** construye la direcciÃ³n (byte alto: ~value~, byte bajo: ~i~)_--_
        *_-_*->** lee la direcciÃ³n de la memoria de la CPU (~this.ppu.cpu~ devuelve la CPU)_--_
        *_-_*->** asigna el byte obtenido a ~oamRam[i]~_--_
      *_-_*->** suma 513 a ~this.ppu.cpu.extraCycles~_--_
  responses: []
