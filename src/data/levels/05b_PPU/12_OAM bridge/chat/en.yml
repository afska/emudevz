main:
  messages:
  - games also define, at runtime, how the sprites should look ğŸ›¸
  - they do so by writing a table called OAM ("Object Attribute Memory")
  - this table lives in an <internal> memory region called ğŸ  OAM RAM
  responses:
  - how can a game write to ğŸ  OAM RAM? [how]

how:
  messages:
  - "there are two ways:"
  - "1) using the registers ğŸ   OAMAddr and ğŸ“  OAMData"
  - "2) using âš¡  OAMDMA"
  responses:
  - (*) tell me about ğŸ   OAMAddr and ğŸ“  OAMData [addrdata]
  - (*) tell me about âš¡  OAMDMA [dma]
  - let's implement that bridge [exercise]

addrdata:
  messages:
  - there's not much to say about them
  - it's the same as ğŸ“  PPUAddr and ğŸ“¦  PPUData
  - but they access ğŸ  OAM RAM instead of PPU memory
  responses:
  - ...how

dma:
  messages:
  - DMA ("Direct Memory Access") is a hardware mechanism to copy bytes from one memory region to another one really fast
  - in the NEEES, this is provided by the âš¡  OAMDMA register, which let games fill ğŸ  OAM RAM by copying bytes from CPU memory
  - writing ```raw $```~XX~ to that register will copy 256 bytes from CPU addresses ```raw $```~XX~```raw 00```-```raw $```~XX~```raw FF``` to the internal OAM RAM
  - this operation will take around 513 CPU cycles, during which the CPU is suspended
  responses:
  - ...how

exercise:
  messages:
  - ğŸ“š  like you did with `PPUMemory::vram`, add a property called `oamRam` in ğŸ  `PPUMemory`
  - the array should store 256 bytes
  - this time, you don't have to map it, OAM is very <internal>
  - |-
    ğŸ“š  implement these methods in ğŸ“  `OAMData`:
    **onRead()**:
      **->** saves the current OAM address:
        ```javascript const oamAddress = this.ppu.registers.oamAddr.value;```
        (the `value` field is defined in `InMemoryRegister` and represents the current value)
      **->** returns the corresponding byte from OAM RAM, using `oamAddress`
    **onWrite(value)**:
      **->** saves the current OAM address (`oamAddress`)
      **->** writes `value` to the corresponding byte from OAM RAM, using `oamAddress`
      **->** increments the OAM address:
        ```javascript this.ppu.registers.oamAddr.setValue(oamAddress + 1);```
  - |-
    ğŸ“š  implement this method in âš¡  `OAMDMA`:
    **onWrite(value)**:
      **->** ```javascript for (i = 0; i < 256; i++)```:
        **->** builds the address (high byte: `value`, low byte: `i`)
        **->** reads the address from CPU memory (```javascript this.ppu.cpu``` retrieves the ğŸ§   `CPU`)
        **->** assigns the obtained byte to ```javascript oamRam[i]```
      **->** adds 513 to ```javascript this.ppu.cpu.extraCycles```
  responses: []

corollary:
  messages:
  - when launching a game, you'll now able to visualize the OAM and its sprites in the ğŸ  <debugger window>
  responses:
  - â–¶ï¸  continue [end]
