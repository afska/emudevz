main:
  messages:
  - el mapa de memoria de la PPU tiene una secciÃ³n dedicada para 4 name tables, en ~PPU $2000-$2FFF~
  - cada name table es de 1024 bytes (o $400 en hexadecimal), por lo que estas 4 tablas estÃ¡n en las direcciones $2000, $2400, $2800 y $2C00
  - pero el hardware real de la NEEES solo tiene VRAM para <dos> de ellas
  - lo que termina sucediendo es que el mapper espeja las otras de formas divertidas âœ¨
  - y ese espejado ("mirroring") es Ãºtil para que los juegos implementen scrolling
  - revisÃ©moslas
  responses:
  - genial, a ver ğŸ‘€ [show]
  - <<level.isCompleted || m.$exercise>> ğŸ“š  llÃ©vame a la acciÃ³n [implement]

show:
  messages:
  - llamemos a las name tables "fÃ­sicas" (las que realmente podemos almacenar en VRAM) "A" y "B"
  - el mirroring "HORIZONTAL" conecta $2000 y $2400 a la primera name table fÃ­sica ("A") y $2800 y $2C00 a la segunda name table fÃ­sica ("B")
  - <{horizontal.png}>
  - Â¿entiendes? estÃ¡n reflejadas horizontalmente ğŸ˜‰
  responses:
  - Â¡sÃ­! [vertical]

vertical:
  messages:
  - el mirroring "VERTICAL" conecta $2000 a "A" y $2400 a "B", luego repite todo en $2800 y $2C00"
  - <{vertical.png}>
  - y ahora estÃ¡n reflejadas verticalmente ğŸ˜Š
  responses:
  - claro [single]

single:
  messages:
  - tambiÃ©n hay juegos que usan una Ãºnica name table, repetida 4 veces (dejando la otra name table fÃ­sica sin usar)
  - <{single.png}>
  - dependiendo del mapper, esto tambiÃ©n podrÃ­a ser "B" cuatro veces
  - llamamos al primero "ONE_SCREEN_LOWER_BANK" y al segundo "ONE_SCREEN_UPPER_BANK"
  responses:
  - tiene sentido [fourscreen]

fourscreen:
  messages:
  - finalmente, hay algunos cartuchos de juegos que contienen RAM extra para 2 name tables fÃ­sicas adicionales
  - lo que les permite usar una configuraciÃ³n "FOUR_SCREEN"
  - <{4screen.png}>
  - esta es la razÃ³n por la que definimos nuestra propiedad `vram` como un array de 4096 bytes en `PPUScreen`
  responses:
  - implementemos esto [implement]

implement:
  run: |
    set((m) => m.$exercise = true);
  messages:
  - traduje los tipos de mapeo en una linda tabla aquÃ­ ğŸ“„  ~/lib/ppu/mirroringTypes.js~
  - las claves (`$2000`, `$2400`, `$2800` y `$2C00`) representan las direcciones lÃ³gicas de la PPU
  - y los valores (principalmente `0x000` y `0x400`) son los desplazamientos de las name tables fÃ­sicas dentro del array `PPUMemory::vram`
  - ğŸ“š  en `PPUMemory`, importa el archivo `mirroringTypes`
  - |-
    ğŸ“š  define este mÃ©todo:
    **changeNameTableMirroringTo(mirroringId)**:
      **->** si `this.cartridge.header.mirroringId === "FOUR_SCREEN"`
        **->** asigna `mirroringId = "FOUR_SCREEN"`
      **->** asigna `this.mirroringId = mirroringId`
      **->** asigna `this._mirroring = mirroringTypes[mirroringId]`
      (los mappers llamarÃ¡n a este mÃ©todo para cambiar el tipo de mirroring cuando lo necesiten)
  - ğŸ“š  cambia `onLoad(...)` para que llame al nuevo mÃ©todo con el mirroring inicial (recuerda que esto estÃ¡ guardado en `cartridge.header.mirroringId`)
  - ğŸ“š  mapea los rangos $2000-$23FF, $2400-$27FF, $2800-$2BFF y $2C00-$2FFF a VRAM, basado en el `mirroring` actual (tanto lecturas como escrituras)
  responses:
  - Â¿por ejemplo? ğŸ§ [example]

example:
  messages:
  - busca la secciÃ³n "Name tables 0 to 3 (VRAM + mirror)" en ambos mÃ©todos `read(...)` y `write(...)`
  - |-
    actualmente, `read(...)` deberÃ­a verse asÃ­:
      ```javascript
      if (address >= 0x2000 && address <= 0x2fff)
        return this.vram[address - 0x2000];
      ```
  - necesitas mapear las 4 secciones segÃºn a dÃ³nde apunte `this._mirroring`
  - |-
    implementemos los primeros dos casos
      ```javascript
      if (address >= 0x2000 && address <= 0x2fff) {
        if (address >= 0x2000 && address < 0x2400)
          return this.vram[this._mirroring.$2000 + (address - 0x2000)];
        if (address >= 0x2400 && address < 0x2800)
          return this.vram[this._mirroring.$2400 + (address - 0x2400)];
        // TODO: Â¡Termina los demÃ¡s!
      }
      ```
  responses: []
