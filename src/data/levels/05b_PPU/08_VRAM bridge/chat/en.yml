---
main:
  messages:
  - games define, at runtime, how the background should look ğŸï¸
  - they create a map using tiles, and store it in ğŸ  VRAM
  responses:
  - how can a game write to ğŸ  VRAM? [how]

how:
  messages:
  - through the video registers called ğŸ“  ~PPUAddr~ and ğŸ“¦  ~PPUData~
  - they are like a bridge that connects the ğŸ§   CPU and ğŸ–¥ï¸  PPU
  - first, games put the VRAM address they want to write in ğŸ“  ~PPUAddr~
  - "(two consecutive writes: one for the <high byte>, and one for the <low byte>)"
  - then, they write to ğŸ“¦  ~PPUData~ the byte they want to put in that address
  - <{PPUAddr_PPUData.png}>
  responses:
  - nice, I guess I need to define the VRAM somewhere [define]

define:
  messages:
  - yeah, better start with that
  - ğŸ“š  _-_like you did with `CPUMemory::ram`, add a property called `vram` in `PPUMemory`_--_
  - _-_the array should store 4096 bytes_--_
  - (I know I said multiple times that there's only 2 KiB of VRAM, but some games extend that memory using extra chips in their cartridge, and it's easier to emulate those by just allocating a big 4 KiB chunk ğŸ¤· )
  - ğŸ“š  _-_map the range $2000-$2FFF to VRAM (both reads and writes)_--_
  - |-
    ğŸ“š  _-_implement these methods in `PPUAddr`:_--_
    *_-_*onLoad()**:_--_
      *_-_*->** initializes two properties:_--_
        _-_~this.latch = false~_--_
        _-_~this.address = 0~_--_
        _-_(we'll use these to model the alternating behavior between high byte / low byte on every write operation)_--_
    *_-_*onWrite(value)**:_--_
      *_-_*->** if ~latch~ is ~false~:_--_
        *_-_*->** writes only the <high part> of ~address~, using ~value~_--_
          _-_(leave the low part as it was before)_--_
      *_-_*->** if it's ~true~:_--_
        *_-_*->** writes only the <low part> of ~address~, using ~value~_--_
          _-_(leave the high part as it was before)_--_
      _-_(you can use ~buildU16(...)~, ~highByteOf(...)~, and ~lowByteOf(...)~)_--_
      *_-_*->** switches ~latch~ to the opposite value_--_
  - |-
    ğŸ“š  _-_implement these methods in `PPUData`:_--_
    *_-_*onWrite(value)**:_--_
      *_-_*->** writes ~value~ to the PPU memory address ~ppuAddr.address~_--_
        _-_(you can access the `PPUMemory` instance with ~this.ppu.memory~)_--_
        _-_(you can access the `PPUAddr` instance with ~this.ppu.registers.ppuAddr~)_--_
      *_-_*->** calls ~this._incrementAddress()~_--_
    *_-_*_incrementAddress()**:_--_
      *_-_*->** if ~ppuCtrl.vramAddressIncrement32~ is ~1~:_--_
        *_-_*->** increments ~ppuAddr.address~ by 32_--_
      *_-_*->** if not:_--_
        *_-_*->** increments ~ppuAddr.address~ 1 time_--_
     *_-_*[!]** make sure the address never exceeds 65535 by using `byte.toU16(...)`_--_
  - |-
    ğŸ“š  _-_lastly, modify in `PPUStatus`:_--_
    *_-_*onRead()**:_--_
      *_-_*->** after resetting ~isInVBlankInterval~, it also resets the ~latch~ from `PPUAddr`_--_
  responses:
  - what's this address increment? ğŸ¤” [increment]

increment:
  messages:
  - yeah, I forgot to tell you
  - the PPU increments the address automatically after writing to ğŸ“¦  PPUData
  - depending on what's in ğŸ›ï¸  ~PPUCtrl~, this can be a ~+1~ or a ~+32~
  responses: []
