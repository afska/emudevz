---
main:
  messages:
  - los juegos definen, en tiempo de ejecuciÃ³n, cÃ³mo debe lucir el fondo ğŸï¸
  - crean un mapa usando tiles y lo almacenan en la ğŸ  VRAM
  responses:
  - Â¿cÃ³mo puede un juego escribir en la ğŸ  VRAM? [how]

how:
  messages:
  - a travÃ©s de los registros de video llamados ğŸ“  ~PPUAddr~ y ğŸ“¦  ~PPUData~
  - son como un puente que conecta la ğŸ§   CPU y ğŸ–¥ï¸  PPU
  - primero, los juegos ponen la direcciÃ³n de VRAM que quieren escribir en ğŸ“  ~PPUAddr~
  - "(dos escrituras consecutivas: una para el <high byte>, y una para el <low byte>)"
  - luego, escriben en ğŸ“¦  ~PPUData~ el byte que quieren poner en esa direcciÃ³n
  - <{PPUAddr_PPUData.png}>
  responses:
  - bien, supongo que necesito definir la VRAM en algÃºn lugar [define]

define:
  messages:
  - sÃ­, mejor empieza por eso
  - ğŸ“š  como hiciste con `CPUMemory::ram`, agrega una propiedad llamada `vram` en `PPUMemory`
  - el array deberÃ­a almacenar 4096 bytes
  - (sÃ© que dije varias veces que solo hay 2 KiB de VRAM, pero algunos juegos extienden esa memoria usando chips extra en su cartucho, y es mÃ¡s fÃ¡cil emular esos simplemente asignando un gran bloque de 4 KiB ğŸ¤· )
  - ğŸ“š  mapea el rango $2000-$2FFF a VRAM (tanto lecturas como escrituras)
  - |-
    ğŸ“š  implementa estos mÃ©todos en `PPUAddr`:
    **onLoad()**:
      **->** inicializa dos propiedades:
        `this.latch = false`
        `this.address = 0`
        (usaremos estas para modelar el comportamiento alternante entre byte alto / byte bajo en cada operaciÃ³n de escritura)
    **onWrite(value)**:
      **->** si `latch` es `false`:
        **->** escribe solo el high byte de `address`, usando `value`
          (deja la parte baja como estaba antes)
      **->** si es `true`:
        **->** escribe solo el low byte de `address`, usando `value`
          (deja la parte alta como estaba antes)
      (puedes usar `buildU16(...)`, `highByteOf(...)`, y `lowByteOf(...)`)
      **->** cambia `latch` al valor opuesto
  - |-
    ğŸ“š  implementa estos mÃ©todos en `PPUData`:
    **onWrite(value)**:
      **->** escribe `value` en la direcciÃ³n de memoria PPU `ppuAddr.address`
        (puedes acceder a la instancia `PPUMemory` con `this.ppu.memory`)
        (puedes acceder a la instancia `PPUAddr` con `this.ppu.registers.ppuAddr`)
      **->** llama a `this._incrementAddress()`
    **_incrementAddress()**:
      **->** si `ppuCtrl.vramAddressIncrement32` es ~1~:
        **->** incrementa `ppuAddr.address` por 32
      **->** si no:
        **->** incrementa `ppuAddr.address` 1 vez
     **[!]** asegÃºrate de que la direcciÃ³n nunca exceda 65535 usando `byte.toU16(...)`
  - |-
    ğŸ“š  por Ãºltimo, modifica en `PPUStatus`:
    **onRead()**:
      **->** luego de resetear `isInVBlankInterval`, tambiÃ©n resetea el `latch` de `PPUAddr`
  responses:
  - Â¿quÃ© es este incremento de direcciÃ³n? ğŸ¤” [increment]

increment:
  messages:
  - sÃ­, olvidÃ© mencionarte
  - la PPU incrementa la direcciÃ³n automÃ¡ticamente despuÃ©s de escribir en ğŸ“¦  PPUData
  - dependiendo de lo que estÃ© en ğŸ›ï¸  ~PPUCtrl~, esto puede ser un ~+1~ o un ~+32~
  responses: []
