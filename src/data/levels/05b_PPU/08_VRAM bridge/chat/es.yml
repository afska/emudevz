---
main:
  messages:
  - los juegos definen, en tiempo de ejecuciÃ³n, cÃ³mo debe lucir el fondo ğŸï¸
  - crean un mapa usando tiles y lo almacenan en la ğŸ  VRAM
  responses:
  - Â¿cÃ³mo puede un juego escribir en la ğŸ  VRAM? [how]

how:
  messages:
  - a travÃ©s de los registros de video llamados ğŸ“  PPUAddr y ğŸ“¦  PPUData
  - son como un puente que conecta la ğŸ§   CPU y ğŸ–¥ï¸  PPU
  - primero, los juegos ponen la direcciÃ³n de VRAM que quieren escribir en ğŸ“  PPUAddr
  - "(dos escrituras consecutivas: una para el byte alto, y una para el byte bajo)"
  - luego, escriben en ğŸ“¦  PPUData el byte que quieren poner en esa direcciÃ³n
  - <{PPUAddr_PPUData.png}>
  responses:
  - bien, supongo que necesito definir la VRAM en algÃºn lugar [exercise]

exercise:
  messages:
  - sÃ­, mejor empieza por eso
  - ğŸ“š  como hiciste con `CPUMemory::ram`, agrega una propiedad llamada `vram` en ğŸ  `PPUMemory`
  - el array deberÃ­a almacenar 4096 bytes
  - (sÃ© que dije varias veces que solo hay 2 KiB de VRAM, pero algunos juegos extienden esa memoria usando chips extra en su cartucho, y es mÃ¡s fÃ¡cil emular esos simplemente asignando un gran bloque de 4 KiB ğŸ¤· )
  - ğŸ“š  mapea el rango $2000-$2FFF a VRAM (tanto lecturas como escrituras)
  - |-
    ğŸ“š  implementa estos mÃ©todos en ğŸ“  `PPUAddr`:
    **onLoad()**:
      **->** inicializa dos propiedades:
        ```javascript this.latch = false```
        ```javascript this.address = 0```
        (usaremos estas para modelar el comportamiento alternante entre byte alto / byte bajo en cada operaciÃ³n de escritura)
    **onWrite(value)**:
      **->** si `latch` es ```javascript false```:
        **->** escribe solo el byte alto de `address`, usando `value`
          (deja la parte baja como estaba antes)
      **->** si es ```javascript true```:
        **->** escribe solo el byte bajo de `address`, usando `value`
          (deja la parte alta como estaba antes)
      (puedes usar `buildU16(...)`, `highByteOf(...)`, y `lowByteOf(...)`)
      **->** cambia `latch` al valor opuesto
  - |-
    ğŸ“š  implementa estos mÃ©todos en ğŸ“¦  `PPUData`:
    **onWrite(value)**:
      **->** escribe `value` en la direcciÃ³n PPU ```javascript ppuAddr.address```
        (puedes acceder a la instancia ğŸ  `PPUMemory` con ```javascript this.ppu.memory```)
        (puedes acceder a la instancia ğŸ“  `PPUAddr` con ```javascript this.ppu.registers.ppuAddr```)
      **->** llama a ```javascript this._incrementAddress()```
    **_incrementAddress()**:
      **->** si ```javascript ppuCtrl.vramAddressIncrement32``` es ~1~:
        **->** incrementa ```javascript ppuAddr.address``` por 32
      **->** si no:
        **->** incrementa ```javascript ppuAddr.address``` 1 vez
     **[!]** asegÃºrate de que la direcciÃ³n nunca exceda 65535 usando `byte.toU16(...)`
  - |-
    ğŸ“š  por Ãºltimo, <modifica> en ğŸ“Š  `PPUStatus`:
    **onRead()**:
      **->** luego de resetear `isInVBlankInterval`, tambiÃ©n resetea el `latch` de ğŸ“  `PPUAddr`
  responses:
  - (*) Â¿quÃ© es este incremento de direcciÃ³n? ğŸ¤” [increment]

increment:
  messages:
  - sÃ­, olvidÃ© mencionarte
  - la PPU incrementa la direcciÃ³n automÃ¡ticamente despuÃ©s de escribir en ğŸ“¦  PPUData
  - dependiendo de lo que estÃ© en ğŸ›ï¸  PPUCtrl, esto puede ser un ~+1~ o un ~+32~
  - este autoincremento es Ãºtil para que los juegos llenen la VRAM mÃ¡s rÃ¡pido
  responses:
  - ...exercise
