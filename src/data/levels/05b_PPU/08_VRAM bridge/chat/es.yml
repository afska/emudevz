---
main:
  messages:
  - los juegos definen, en tiempo de ejecuciÃ³n, cÃ³mo debe lucir el fondo ğŸï¸
  - crean un mapa usando tiles y lo almacenan en la ğŸ  VRAM
  responses:
  - Â¿cÃ³mo puede un juego escribir en la ğŸ  VRAM? [how]

how:
  messages:
  - a travÃ©s de los registros de video llamados ğŸ“  ~PPUAddr~ y ğŸ“¦  ~PPUData~
  - son como un puente que conecta la ğŸ§   CPU y ğŸ–¥ï¸  PPU
  - primero, los juegos ponen la direcciÃ³n de VRAM que quieren escribir en ğŸ“  ~PPUAddr~
  - "(dos escrituras consecutivas: una para el <high byte>, y una para el <low byte>)"
  - luego, escriben en ğŸ“¦  ~PPUData~ el byte que quieren poner en esa direcciÃ³n
  - <{PPUAddr_PPUData.png}>
  responses:
  - bien, supongo que necesito definir la VRAM en algÃºn lugar [define]

define:
  messages:
  - sÃ­, mejor empieza por eso
  - ğŸ“š  _-_como hiciste con `CPUMemory::ram`, agrega una propiedad llamada `vram` en `PPUMemory`_--_
  - _-_el array deberÃ­a almacenar 4096 bytes_--_
  - (sÃ© que dije varias veces que solo hay 2 KiB de VRAM, pero algunos juegos extienden esa memoria usando chips extra en su cartucho, y es mÃ¡s fÃ¡cil emular esos simplemente asignando un gran bloque de 4 KiB ğŸ¤· )
  - ğŸ“š  _-_mapea el rango $2000-$2FFF a VRAM (tanto lecturas como escrituras)_--_
  - |-
    ğŸ“š  _-_implementa estos mÃ©todos en `PPUAddr`:_--_
    *_-_*onLoad()**:_--_
      *_-_*->** inicializa dos propiedades:_--_
        _-_~this.latch = false~_--_
        _-_~this.address = 0~_--_
        _-_(usaremos estas para modelar el comportamiento alternante entre byte alto / byte bajo en cada operaciÃ³n de escritura)_--_
    *_-_*onWrite(value)**:_--_
      *_-_*->** si ~latch~ es ~false~:_--_
        *_-_*->** escribe solo la <parte alta> de ~address~, usando ~value~_--_
          _-_(deja la parte baja como estaba antes)_--_
      *_-_*->** si es ~true~:_--_
        *_-_*->** escribe solo la <parte baja> de ~address~, usando ~value~_--_
          _-_(deja la parte alta como estaba antes)_--_
      _-_(puedes usar ~buildU16(...)~, ~highByteOf(...)~, y ~lowByteOf(...)~)_--_
      *_-_*->** cambia ~latch~ al valor opuesto_--_
  - |-
    ğŸ“š  _-_implementa estos mÃ©todos en `PPUData`:_--_
    *_-_*onWrite(value)**:_--_
      *_-_*->** escribe ~value~ en la direcciÃ³n de memoria PPU ~ppuAddr.address~_--_
        _-_(puedes acceder a la instancia `PPUMemory` con ~this.ppu.memory~)_--_
        _-_(puedes acceder a la instancia `PPUAddr` con ~this.ppu.registers.ppuAddr~)_--_
      *_-_*->** llama a ~this._incrementAddress()~_--_
    *_-_*_incrementAddress()**:_--_
      *_-_*->** si ~ppuCtrl.vramAddressIncrement32~ es ~1~:_--_
        *_-_*->** incrementa ~ppuAddr.address~ por 32_--_
      *_-_*->** si no:_--_
        *_-_*->** incrementa ~ppuAddr.address~ 1 vez_--_
     *_-_*[!]** asegÃºrate de que la direcciÃ³n nunca exceda 65535 usando `byte.toU16(...)`_--_
  - |-
    ğŸ“š  _-_por Ãºltimo, modifica en `PPUStatus`:_--_
    *_-_*onRead()**:_--_
      *_-_*->** luego de resetear ~isInVBlankInterval~, tambiÃ©n resetea el ~latch~ de `PPUAddr`_--_
  responses:
  - Â¿quÃ© es este incremento de direcciÃ³n? ğŸ¤” [increment]

increment:
  messages:
  - sÃ­, olvidÃ© mencionarte
  - la PPU incrementa la direcciÃ³n automÃ¡ticamente despuÃ©s de escribir en ğŸ“¦  PPUData
  - dependiendo de lo que estÃ© en ğŸ›ï¸  ~PPUCtrl~, esto puede ser un ~+1~ o un ~+32~
  responses: []
