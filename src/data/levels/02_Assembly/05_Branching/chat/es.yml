---
main:
  run: |
    set((m) => {
      m.chat.stopBlock = locales.get("not_now");
      m.$canRun = false;
      m.$canEdit = false;
    });
  messages:
  - hasta ahora, solo corrimos programas sin <bifurcaciones>
  - vamos a cambiar eso
  - el lenguaje ensamblador para 6502 tiene mÃºltiples instrucciones para bifurcar ğŸŒ²
  - todas ellas saltan cuando ciertas banderas estÃ¡n encendidas o no
  responses:
  - (*) Â¿"para 6502"? ğŸ¤” [asm6502]
  - bueno y cÃ³mo salto [how]

asm6502:
  messages:
  - ese es el nombre del procesador de la NEEES, "6502"
  - cada lenguaje ensamblador estÃ¡ diseÃ±ado para una CPU especÃ­fica
  - con su propio conjunto de instrucciones
  - asÃ­ que, estamos escribiendo "lenguaje ensamblador para 6502" ğŸ™‚
  responses:
  - ...main

how:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - vamos a analizar `BNE`
  - ("Branch on Not Equal")
  - corre las primeras 5 instrucciones para ver quÃ© hacen â©
  events:
  - step [step1]

step1:
  messages: []
  events:
  - step [step2]

step2:
  messages: []
  events:
  - step [step3]

step3:
  messages: []
  events:
  - step [step4]

step4:
  messages: []
  events:
  - step [step5]

step5:
  run: |
    set((m) => m.$canRun = false);
  messages:
  - esto es lo que pasÃ³
  - "`CPX #3` \"ComPara\" [X] con 3, y activa la Bandera Zero si son iguales"
  - "[X] tiene un 7, y eso no es igual a 3, asÃ­ que ~Z~ = 0"
  - "`BNE @decrement` salta a esa etiqueta si la Bandera Zero no estÃ¡ encendida"
  - Â¡que no lo estÃ¡! asÃ­ que saltÃ³ ğŸ¦˜
  - ([X] y 3 eran "Not Equal", por eso el nombre)
  responses:
  - ah, ya veo [oh]

oh:
  run: |
    set((m) => m.$canRun = true);
  messages:
  - ahora, corre el resto del cÃ³digo â©
  events:
  - end [exercise]

exercise:
  run: |
    level.fillContentFromTemp();
    set((m) => {
      m.chat.stopBlock = null;
      m.$canRun = true;
      m.$canEdit = true;
      m.content.useTemp = false;
    });
  messages:
  - el opuesto de `BNE` es `BEQ`, que salta cuando los nÃºmeros son <iguales>
  - vamos a practicar ğŸ‘¾
  - ğŸ“š  borra el cÃ³digo actual
  - ğŸ“š  y construye un programa que lea el valor de $4080
  - ğŸ“š  si tiene un 7, escribe $EE en $40BF
  - ğŸ“š  si no, escribe $AA en $40BF
  - ğŸ“š  luego, ejecuta el comando `test`
  responses:
  - momento, Â¿cÃ³mo pruebo esto? ğŸ§ª [testing]
  - necesito ayuda ğŸ˜… [help]

testing:
  messages:
  - configurÃ© un <generador de nÃºmeros aleatorios> ğŸ”¢
  - cada vez que cambies/corras tu cÃ³digo, escribirÃ¡ un 7 o un byte aleatorio en $4080
  - con ~50%~ de probabilidades cada cosa
  - asÃ­ que cuando sea 7, tu cÃ³digo deberÃ­a escribir $EE
  - y cuando no, $AA tendrÃ­a que ser escrito
  responses:
  - necesito ayuda ğŸ˜… [help]

help:
  messages:
  - ğŸ”€  siempre querrÃ¡s usar `BEQ` y `BNE` luego de una instrucciÃ³n de comparaciÃ³n (como `CPX`)
  - "`CPX` asigna la bandera ~Z~=1 si [X] es igual al valor, y luego `BEQ`/`BNE` saltan dependiendo de si ~Z~ es 1 o 0"
  - <{CPX_BEQ.png}>
  - ğŸ·ï¸  recuerda que la ejecuciÃ³n siempre es de arriba hacia abajo, ignorando etiquetas
  - por lo que probablemente en algÃºn momento necesites <frenar el programa> (para evitar que "siga de largo")
  - ğŸ›‘  para eso, puedes poner una etiqueta al final del cÃ³digo
  - y usar una instrucciÃ³n de bifurcaciÃ³n para saltar a ella
  - o mÃ¡s fÃ¡cil, usa la instrucciÃ³n `BRK`, que interrumpe la ejecuciÃ³n ğŸ˜‰
  - <{BRK.png}>
  responses: []
