---
main:
  run: |
    set((m) => {
      m.chat.stopBlock = locales.get("not_now");
      m.$canRun = false;
      m.$canEdit = false;
    });
  messages:
  - so far, we only ran programs without any <branching> logic
  - let's change that
  - 6502 assembly has multiple branching instructions ğŸŒ²
  - all of which branch on whether certain flags are set or not
  responses:
  - (*) 6502 what? ğŸ¤” [asm6502]
  - ok how do I branch [how]

asm6502:
  messages:
  - that's the name of the NEEES processor, "6502"
  - each assembly language targets one specific CPU
  - with its own set of instructions
  - so, we're writing "6502 assembly" ğŸ™‚
  responses:
  - ...main

how:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - we'll be looking at `BNE`
  - ("Branch on Not Equal")
  - run the first 5 instructions to see what they do â©
  events:
  - step [step1]

step1:
  messages: []
  events:
  - step [step2]

step2:
  messages: []
  events:
  - step [step3]

step3:
  messages: []
  events:
  - step [step4]

step4:
  messages: []
  events:
  - step [step5]

step5:
  run: |
    set((m) => m.$canRun = false);
  messages:
  - here's what happened
  - "`CPX #3` \"ComPares\" [X] with 3, and sets the Zero Flag if they're equal"
  - "[X] has a 7, and that's not equal to 3, so ~Z~ = 0"
  - "`BNE @decrement` jumps to that label if the Zero Flag is not set"
  - which is not! so it jumped ğŸ¦˜
  - ([X] and 3 were "Not Equal", hence the name)
  responses:
  - oh, I see [oh]

oh:
  run: |
    set((m) => m.$canRun = true);
  messages:
  - now, run the rest of the code â©
  events:
  - end [exercise]

exercise:
  run: |
    level.fillContentFromTemp();
    set((m) => {
      m.chat.stopBlock = null;
      m.$canRun = true;
      m.$canEdit = true;
      m.content.useTemp = false;
    });
  messages:
  - the opposite of `BNE` is `BEQ`, which jumps when the numbers are <equal>
  - let's practice ğŸ‘¾
  - ğŸ“š  delete the current code
  - ğŸ“š  and build a program that reads the value of $4080
  - ğŸ“š  if it has a 7, writes $EE to $40BF
  - ğŸ“š  if not, writes $AA to $40BF
  - ğŸ“š  then, run the `test` command
  responses:
  - wait, how do I test this? ğŸ§ª [testing]
  - I need help ğŸ˜… [help]

testing:
  messages:
  - I've set up a <random number generator> ğŸ”¢
  - every time you change/run your code, it'll set either a 7 or another random byte on $4080
  - with a ~50%~ chance each
  - so when it's 7, your code should write $EE
  - and when it's not, $AA should be written
  responses:
  - I need help ğŸ˜… [help]

help:
  messages:
  - ğŸ”€  you want to always use `BEQ` and `BNE` after a comparison instruction (like `CPX`)
  - "`CPX` sets the flag ~Z~=1 if [X] equals the value, and then `BEQ`/`BNE` jump depending on whether ~Z~ is 1 or 0"
  - <{CPX_BEQ.png}>
  - ğŸ·ï¸  remember that execution always goes from top to bottom, ignoring labels
  - therefore, at some point, you may need to <stop the program> (to prevent it from advancing to the next label)
  - ğŸ›‘  for that, you can put a label at the very end of the code
  - and use a branch instruction to jump to it
  - or more simply, just use the `BRK` instruction, which halts the execution ğŸ˜‰
  - <{BRK.png}>
  responses: []
