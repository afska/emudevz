---
main:
  run: |
    set((m) => {
      m.chat.winOnEnd = true;
      m.chat.stopBlock = locales.get("not_now");
      m.$canRun = false;
    });
    {{Bottom}}.setMemoryStart(0x0);
  messages:
  - ahora, los mÃ¡s dementes ğŸ˜“
  - empecemos con "Indexed Indirect"
  - es como una mezcla entre "Zero Page,X" e "Indirect"
  - bÃ¡sicamente, tomas la direcciÃ³n de la pÃ¡gina cero, sumas el valor de [X] a ella
  - luego usas eso para buscar una direcciÃ³n de dos bytes
  responses:
  - esto estÃ¡ empezando a volverse oscuro [what]

what:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - lo sÃ© ğŸ˜… ğŸ”«
  - probemos con un ejemplo
  - corre las primeras 4 instrucciones â©
  events:
  - step [step1]

step1:
  messages: []
  events:
  - step [step2]

step2:
  messages: []
  events:
  - step [step3]

step3:
  messages: []
  events:
  - step [step4]

step4:
  run: |
    set((m) => m.$canRun = false);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - hemos configurado la memoria para direccionamiento indirecto
  - en la direcciÃ³n $0003, tenemos un $80
  - en la direcciÃ³n $0004, tenemos un $40
  - ahora voy a cambiar el <Visor de Memoria> a la secciÃ³n habitual
  - ejecuta las otras 3 instrucciones â©
  events:
  - step [step5]

step5:
  run: |
    {{Bottom}}.setMemoryStart(0x4020);
    {{Bottom}}.setSelectedCells([0x402c, 0x402d]);
  messages: []
  events:
  - step [step6]

step6:
  messages: []
  events:
  - step [step7]

step7:
  run: |
    set((m) => m.$canRun = false);
  messages:
  - cargamos un $FA en [A] y un $02 en [X]
  - "`STA ($01,X)` puede ser interpretado como `STA ($01+X)`"
  - por lo que si sumamos [X], obtendrÃ­amos `STA ($0003)`
  - desde aquÃ­, las cosas proceden como un direccionamiento "Indirect" estÃ¡ndar
  - esto termina escribiendo el valor de [A] en $4080
  - <{STA_indexedindirect.png}>
  responses:
  - (*) Â¿cÃ³mo es eso? ğŸ¤¨ [whatwasthat]
  - tiene todo el sentido ğŸ‘ [makessense]

whatwasthat:
  messages:
  - Â¿recuerdas el modo "Indirect"?
  - construye una direcciÃ³n leyendo otra direcciÃ³n y su byte consecutivo
  - en este caso, leyÃ³ un $80 de $0003 y un $40 de $0004
  - usÃ³ el primero como el byte menos significativo
  - y el Ãºltimo como el byte mÃ¡s significativo
  - por lo que la direcciÃ³n resultante fue $4080 âœ¨
  responses:
  - ...step7

makessense:
  run: |
    {{Bottom}}.setSelectedCells([0x4030, 0x4031]);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - hablemos de "Indirect Indexed"
  - el Ãºltimo, lo prometo ğŸ¤
  - en lugar de sumar [X] a la direcciÃ³n <antes> de evaluar la indirecciÃ³n
  - suma [Y] justo <despuÃ©s> de hacerlo
  - ejecuta el cÃ³digo restante â©
  - y ten en mente que hay un $BE precargado en $4085
  events:
  - step [step8]

step8:
  messages: []
  events:
  - step [step9]

step9:
  messages:
  - ese $BE fue cargado en [A] ğŸ¤¯
  - como vimos anteriormente, en nuestra configuraciÃ³n actual ($0003) evalÃºa a $4080
  - la instrucciÃ³n solo sumÃ³ [Y] a eso, asÃ­ que la direcciÃ³n final fue $4085
  - <{LDA_indirectindexed.png}>
  responses:
  - creo que me estresÃ©, Â¿podemos omitir la prÃ¡ctica? ğŸ˜“ [skip]

skip:
  messages:
  - claro, no vas a ver mucho esto de todas formas
  - vas a programar un emulador
  - por lo que necesitas construir un <intÃ©rprete> para estas cosas
  - no las cosas en sÃ­ mismas ğŸ˜‰
  responses:
  - entiendo... [end]
