---
main:
  run: |
    set((m) => {
      m.chat.winOnEnd = true;
      m.chat.stopBlock = locales.get("not_now");
      m.$canRun = false;
    });
  messages:
  - let me introduce you to the code editor
  - well, it's not an <editor> yet ğŸ˜…
  - just a <viewer>
  - it has an example of a basic NEEES program
  responses:
  - (*) the viewer doesn't scare me, what it does is the weird looking numbers at the bottom [debugger]
  - what language is this? ğŸ˜® [language]
  - â­ï¸  I already know this [iknow]

iknow:
  messages:
  - ğŸ¤”
  - are you <really> familiar with 6502 assembly?
  - (registers, flags, branching, addressing modes, stack and subroutines)
  - if not, in the next chapter you will <suffer>
  - meh, you can go back and play it whenever you want, anyway
  - do you want to skip the WHOLE chapter?
  responses:
  - â­ï¸  yes, skip [skip]
  - âŒ  no, I'm not sure [main]

skip:
  run: |
    level.unlockLetsPlayLevelIfNeeded("lets-play-spacegulls");
    const book = store.getState().book.instance;
    const chapter = book.getChapterOf(level.id);
    const lastLevelId = _.last(chapter.levels).id;
    const nextLevelId = book.nextIdOf(lastLevelId, true);
    store.dispatch.savedata.unlockChapter(nextLevelId);
    store.dispatch.savedata.advanceTo(nextLevelId);
  messages: []
  events:
  - null [end]
  
debugger:
  messages:
  - the CPU debugger?
  - don't you worry
  - I'll explain everything!
  responses:
  - ...main

language:
  messages:
  - it's assembly language!
  - the lowest level of abstraction in computers ğŸ’»
  - it translates directly to the bytes that are executed by the CPU
  responses:
  - "\"translates\"? [machinecode]"

machinecode:
  run: |
    {{Bottom}}.setSelectedCells([0x4020, 0x4021, 0x4022, 0x4023, 0x4024, 0x4025, 0x4026, 0x4027, 0x4028, 0x4029, 0x402A, 0x402B, 0x402C, 0x402D, 0x402E]);
  messages:
  - correct
  - an ~assembler~ converts the assembly code to bytes in memory
  - we call these bytes the machine code, and that's what the CPU understands
  - look at the <Memory Viewer> at the bottom right corner of the screen!
  - in this simulation, the code starts from the $4020 memory address
  - if you place your mouse pointer over one of these addresses, it'll show where each instruction starts
  - <{compilation.png}>
  responses:
  - (*) what's a memory address? [address]
  - what are the other numbers? ğŸ‘€ [otherthings]

address:
  run: |
    set((m) => m.$address = true);
  messages:
  - a number that represents a location in memory ğŸ
  - in the NEEES, they take up 2 bytes
  - so they can go from 0 ($0000) to 65535 ($FFFF)
  - every location (and pretty much everything on the NEEES) can store a single byte
  - a byte can store any number between 0 ($00) and 255 ($FF)
  responses:
  - the NEEES only had 2048 bytes of WRAM, why there are 65536 addresses? [butyousaid]
  - <<!m.$hasEnded>> ...machinecode
  - <<m.$hasEnded>> ...finish

butyousaid:
  messages:
  - great question!
  - it only has 2 KiB of real memory
  - but the CPU can <see> up to 64 KiB
  - so the first two kilobytes are <actual RAM>
  - and the rest is used to interact with the hardware ğŸ’»
  - <{memory.png}>
  - that doesn't matter too much in this chapter
  - we're simulating a 64 KiB RAM for simplicity's sake
  responses:
  - <<!m.$hasEnded>> ...machinecode
  - <<m.$hasEnded>> ...finish

otherthings:
  run-after-messages: |
    {{Bottom}}.setSelectedCells([]);
    set((m) => m.$canRun = true);
  messages:
  - let's run the code and discover it
  - <! Execution enabled.
  - I've added a â©  button to the code section
  - "can you click it? ğŸ™"
  events:
  - step [lda]

lda:
  run: |
    set((m) => m.$canRun = false);
  messages:
  - great!
  - if you were watching carefully, you'll have noticed that [A] changed from $00 to $01
  - and [PC] changed from $4020 to $4022 ğŸ¤¯
  - those are CPU registers, quickly accessible locations
  - each register can hold a single byte (~8~ bits) of data
  - with the exception of [PC] ("Program Counter") which is 2 bytes wide
  responses:
  - what's the purpose of each register? [registers]

registers:
  messages:
  - well, [A] means Accumulator and its use depends on the program
  - "[PC] always points to the next instruction to execute"
  responses:
  - "so, with `LDA #$01` you just told the processor to store the number $01 in [A]? ğŸ˜² [ldaexplanation]"
  - "(*) I'm curious about the others: [X], [Y], and [SP] [theothers]"

theothers:
  run: |
    set((m) => m.$others = true);
  messages:
  - I'll talk about that later, but basically
  - "[X] and [Y] can store any value, just like [A]"
  - they have a special meaning when working with memory addresses ğŸ
  - and [SP] is the "Stack Pointer"
  responses:
  - <<!m.$hasEnded>> ...registers
  - <<m.$hasEnded>> ...finish

ldaexplanation:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - exactly, `LDA` means "LoaD Accumulator"
  - ğŸ’¸  numbers prefixed with ~$~ are in hexadecimal notation
  - "ğŸ”¢  numbers prefixed with ~#~ are literal values"
  - "ğŸ  numbers without the ~#~ prefix refer to memory addresses"
  - now run the next instruction! â©
  events:
  - step [sta]

sta:
  run: |
    set((m) => m.$canRun = false);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - "`STA` means \"STore Accumulator\""
  - and as you can see, it writes the content of [A] to a memory address
  - in this example, to the address $4070
  - so now the $4070 cell of the <Memory Viewer> has a $01
  - try running the remaining instructions â©
  events:
  - end [finish]

finish:
  run: |
    set((m) => m.$hasEnded = true);
    {{Bottom}}.setDelay(500);
  messages:
  - awesome, now you know the basic workings of a CPU
  - click the â®  button and run the simulation as many times as you need
  - when you are ready, we can go to the next level
  responses:
  - ğŸ’ª  I think I'm ready [end]
  - <<!m.$others>> (*) what about [X], [Y], and [SP]? [theothers]
  - <<!m.$address>> (*) again... what's a memory address? [address]
  - (*) I don't like clicking buttons [clicking]

clicking:
  messages:
  - hmm...
  - you can navigate to the code section with ~Alt+Up~
  - then hit ~Alt+Enter~
  - and go back with ~Alt+Left~
  responses:
  - ...finish
