---
main:
  run: |
    if (level.hasStoredContent) $.goTo("exercise");
    else {
      set((m) => {
        m.chat.stopBlock = locales.get("not_now");
        m.$canRun = false;
        m.$canEdit = false;
      });
    }
  messages:
  - the stack ðŸ§±  is a LIFO structure ("Last In, First Out") which programs can use to store values
  - the current stack depth is measured by the "Stack Pointer" ([SP])
  - in a 6502 processor, it lives in memory between $0100 and $01FF ðŸ
  - "[SP] is initially $FF, which points to the last stack byte ($01FF)"
  - when a byte is pushed onto the stack, [SP] becomes $FE (or memory location $01FE), and so on
  responses:
  - and how can I put values on it? [put]

put:
  messages:
  - "you use two instructions:"
  - "â¬†ï¸  `PHA` (\"PusH Accumulator\"), which adds [A] to the stack"
  - "â¬‡ï¸  `PLA` (\"PulL Accumulator\"), which removes the last byte from the stack, and loads it in [A]"
  responses:
  - can you explain to me the example code? [example]

example:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - it creates two loops âž°
  - "`@save` puts odd numbers from $4080 to $4087"
  - and `@load` puts those numbers in reverse order from $4088 to $408F
  - the former <pushes> values onto the stack, the latter <pulls> values from the stack
  - now your debugger has a Stack section ðŸ‘€
  - run the code and check it out for yourself â©
  responses:
  - nice, I get it now [exercise]
  - (*) why doesn't `PLA` remove the value from the stack? [remove]

remove:
  messages:
  - it "removes" it, just by incrementing [SP]
  - the value is kept in memory though ðŸ˜…
  - there's no reason to remove it, as you'd only access the stack with the appropriate instructions
  responses:
  - ...example

exercise:
  run: |
    level.test.precode = "pretest.asm";
    level.fillContentFromTemp();
    set((m) => {
      m.chat.stopBlock = null;
      m.$canRun = true;
      m.$canEdit = true;
      m.content.useTemp = false;
    });
  messages:
  - now, an exercise
  - ðŸ“š  _-_remove all the code_--_
  - _-_your stack will have 2 random preloaded values_--_
  - _-_you just need to pull and load them into 2 consecutive memory addresses_--_
  - _-_then, perform an indirect `JMP` _--_ðŸ¦˜
  - _-_e.g. if your stack has -from top to bottom- $C4 and $3E, when your program finishes, [PC] should be $3EC4_--_
  - _-_run `test` when it's all done _--_ðŸ˜Š
  responses: []
