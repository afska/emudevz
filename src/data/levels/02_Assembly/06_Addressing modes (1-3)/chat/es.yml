---
main:
  run: |
    set((m) => {
      m.chat.stopBlock = locales.get("not_now");
      m.$canRun = false;
      m.$canEdit = false;
    });
  messages:
  - por si no te diste cuenta, todas las instrucciones toman uno o cero <argumentos>
  - y una instrucciÃ³n compilada puede ocupar 1, 2 o 3 bytes
  - <{compilation_full.png}>
  responses:
  - Â¿por quÃ© me estÃ¡s contando esto? [why]

why:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - hay varias formas de referirse estos argumentos
  - y se llaman modos de direccionamiento
  - corre la primera instrucciÃ³n â©
  events:
  - step [implicit]

implicit:
  run: |
    set((m) => m.$canRun = false);
    {{Bottom}}.setSelectedCells([0x4020]);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - la instrucciÃ³n `INX` no toma argumentos, por lo que es de solo 1 byte
  - ([PC] pasÃ³ de $4020 a $4021)
  - esto se llama modo de direccionamiento "Implicit"
  - el argumento estÃ¡ <implÃ­cito> en la instrucciÃ³n misma
  - sigue â©
  events:
  - step [immediate]

immediate:
  run: |
    set((m) => m.$canRun = false);
    {{Bottom}}.setSelectedCells([0x4021, 0x4022]);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - "aquÃ­, `LDA #$08` toma 1 byte como argumento, por lo que ocupa 2 bytes"
  - el "cÃ³digo de operaciÃ³n" (opcode) y el 8
  - esto es el modo de direccionamiento "Immediate"
  - donde el argumento es un byte <literal>
  - sigue â©
  events:
  - step [absolute]

absolute:
  run: |
    set((m) => m.$canRun = false);
    {{Bottom}}.setSelectedCells([0x4023, 0x4024, 0x4025]);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - "`LDA $C002` en cambio toma una direcciÃ³n de memoria"
  - como tiene un argumento de 2 bytes, se compila a 3 bytes
  - este es el modo de direccionamiento "Absolute"
  - donde el argumento es una direcciÃ³n de memoria <completa>
  - sigue â©
  events:
  - step [zeropage]

zeropage:
  run: |
    set((m) => m.$canRun = false);
    {{Bottom}}.setSelectedCells([0x4026, 0x4027]);
  messages:
  - "`LDA $15` tambiÃ©n toma una direcciÃ³n de memoria"
  - pero una corta, porque solo es 1 byte
  - la direcciÃ³n completa serÃ­a $0015
  - eso es el modo de direccionamiento "Zero Page"
  - donde el argumento es una direcciÃ³n de memoria <parcial>
  responses:
  - parece la misma cosa ğŸ˜“ [samething]

samething:
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - es mÃ¡s rÃ¡pido que el modo "Absolute", ya que solo se necesita buscar un byte
  - y ademÃ¡s ocupa menos espacio en el cÃ³digo ensamblado
  - pero solo la primera pÃ¡gina (los primeros 256 bytes) es accesible
  - sigue â©
  events:
  - step [relative]

relative:
  run: |
    set((m) => m.$canRun = false);
    {{Bottom}}.setSelectedCells([0x4028, 0x4029]);
  messages:
  - las instrucciones de bifurcaciÃ³n usan el modo de direccionamiento "Relative"
  - estas toman un solo byte, que es usado como un desplazamiento desde la siguiente instrucciÃ³n
  - mira el cÃ³digo mÃ¡quina de `BNE @label` en $4028
  - $D0 es el opcode de `BNE`, y el $02 de $4029 es el desplazamiento del salto ğŸ¦˜
  - "esto significa que [PC] saltarÃ¡ a $402A + 2: directo hacia $402C, donde comienza `@label`"
  - (omitirÃ¡ los bytes de los dos `INY`s)
  responses:
  - interesante, conque asÃ­ funcionan las bifurcaciones [whoa]

whoa:
  run: |
    {{Bottom}}.setSelectedCells([0x4036, 0x4037, 0x4038]);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - la Ãºltima es un poco complicada ğŸ˜¶
  - "el modo de direccionamiento \"Indirect\" usa una direcciÃ³n absoluta para buscar otra direcciÃ³n"
  - al leer la primera direcciÃ³n obtenemos el byte menos significativo (tambiÃ©n llamado "byte bajo", ```raw $00```~XX~)
  - y leer el byte siguiente (direcciÃ³n + 1) nos da el byte mÃ¡s significativo (tambiÃ©n llamado "byte alto", ```raw $```~XX~```raw 00```)
  - esto puede ser difÃ­cil de entender completamente, asÃ­ que mejor ejecuta el ejemplo â©
  events:
  - step [step1]

step1:
  messages: []
  events:
  - step [step2]

step2:
  messages: []
  events:
  - step [step3]

step3:
  messages: []
  events:
  - step [step4]

step4:
  run: |
    set((m) => m.$canRun = false);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - ahora $4080 contiene $21, y $4081 contiene $40
  - por lo que en este caso, `JMP ($4080)` saltarÃ¡ incondicionalmente a $4021"
  - <{JMP_indirect.png}>
  - creando un bucle infinito â©
  events:
  - step [seeit]

seeit:
  run: |
    set((m) => m.$canRun = false);
  run-after-messages: |
    set((m) => m.$canRun = true);
  messages:
  - Â¿lo ves? saltÃ³, y ahora [PC] apunta a $4021
  responses:
  - ya veo [exercise]

exercise:
  run: |
    level.fillContentFromTemp();
    set((m) => {
      m.chat.stopBlock = null;
      m.$canRun = true;
      m.$canEdit = true;
      m.content.useTemp = false;
    });
    {{Bottom}}.setSelectedCells([]);
  messages:
  - ahÃ­ estÃ¡...
  - ğŸ“š  como ejercicio, modifica el cÃ³digo agregando una instrucciÃ³n `STY $1001` al final
  - ğŸ“š  luego una instrucciÃ³n `INX`
  - ğŸ“š  y por Ãºltimo, cambia las lÃ­neas 10 y 12 para que el `JMP` indirecto vaya directamente a la nueva `INX` ğŸ‘€
  - ğŸ“š  cuando termines, ejecuta el comando `test`
  responses:
  - momento, Â¿quÃ©? [what]

what:
  messages:
  - luego de tu cambio, en vez de saltar hacia atrÃ¡s, deberÃ­a omitir `STY $1001` y saltar a nuestra nueva Ãºltima instrucciÃ³n
  - âš ï¸  no cambies el `JMP` en sÃ­ mismo, la idea es que el mismo `JMP ($4080)` salte a otro lugar
  - necesitarÃ¡s mirar la direcciÃ³n del Ãºltimo `INX` dentro del cÃ³digo mÃ¡quina ğŸ˜‰
  responses: []
