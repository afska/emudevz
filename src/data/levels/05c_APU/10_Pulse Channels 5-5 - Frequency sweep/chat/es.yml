---
main:
  messages:
  - si ejecutaste el emulador, probablemente notaste que los <sonidos de salto> y otros <sfx> suenan un poco...
  - aburridos
  - la unidad de barrido puede cambiar gradualmente la frecuencia hacia arriba o hacia abajo, Â¡creando el mejor efecto de salto producido por <plomeros>! ğŸ‘¨â€ ğŸ”§
  responses:
  - Â¿cÃ³mo funciona? [how]

how:
  messages:
  - es algo parecido a la envolvente, pero en vez de cambiar el <volumen>, cambia el timer del canal, Â¡afectando el <pitch>!
  - es un poco mÃ¡s complejo igual, porque el cambio no es <constante>
  - "los juegos escriben 4 parÃ¡metros en ğŸ§¹  PulseSweep:"
  - â°  un periodo de divisor, que determina quÃ© tan lento cambiarÃ¡ la frecuencia
  - â—  un <shift count>, que determina quÃ© tan gradual serÃ¡ la transiciÃ³n
  - â›”  un <negate flag>, que define si el cambio serÃ¡ hacia abajo o hacia arriba
  - ğŸ”›  un <enable flag>, que activa la unidad de barrido
  - <{frequency_sweep.png;30x30}>
  - |-
    cada half frame el divisor cuenta hacia abajo, y si la cuenta llega a 0, calcula la cantidad de cambio asÃ­:
      ```javascript const sweepDelta = channel.timer >> shiftCount;```
  - |-
    luego, dependiendo del <negate flag>, incrementa o disminuye el timer:
      ```javascript channel.timer += sweepDelta * (negateFlag ? -1 : 1);```
  responses:
  - (*) Â¿quÃ© hace el <right shift>? [shifting]
  - genial, supongo que ahora podemos programarlo [exercise]

shifting:
  messages:
  - "`number >> 1` desplaza los bits de `number` a la derecha, una vez"
  - esto divide el nÃºmero por 2
  - "`number >> 2` lo hace dos veces, y por lo tanto, divide el nÃºmero por 4"
  - asÃ­ que, en la prÃ¡ctica, mayores <shift counts> llevan a cambios mÃ¡s graduales
  responses: 
  - ...how

exercise:
  messages:
  - |-
    ğŸ“š  implementa en ğŸ§¹  `PulseSweep`:
    **onLoad()**:
      **->** usa ```javascript this.addField(...)``` para agregar 4 campos: `shiftCount`, `negateFlag`, `dividerPeriodMinusOne`, `enabledFlag`
      (usa ğŸ“„  ~/docs/apu/audio_registers.es.md~ como referencia)
    **onWrite(value)**:
      **->** asigna el valor con ```javascript this.setValue(...)```
  - |-
    ğŸ“š  crea una clase ğŸ§¹  `FrequencySweep` con lo siguiente:
    **constructor(channel)**:
      **->** guarda el parÃ¡metro como una propiedad (```javascript this.channel```)
      **->** asigna ```javascript this.startFlag = false```
      **->** asigna ```javascript this.dividerCount = 0```
      **->** asigna ```javascript this.mute = false```
    **clock()**:
      **->** si (
          el <enable flag> estÃ¡ encendido <Y>
          el <shift count> es mayor que 0 <Y>
          el <divider count> es 0 <Y>
          ```javascript !this.mute```
        ):
          ```javascript const sweepDelta = this.channel.timer >> register.shiftCount;
          this.channel.timer += sweepDelta * (register.negateFlag ? -1 : 1);```
      
      **->** si el <divider count> es 0 <O> el <start flag> estÃ¡ encendido
        **->** asigna el valor de `dividerPeriodMinusOne` de ğŸ§¹  PulseSweep + 1 a ```javascript this.dividerCount```
        **->** apaga el <start flag>
      **->** si no:
        **->** decrementa el <divider count>
      
      **->** asigna ```javascript this.mute = this.channel.timer < 8 || this.channel.timer > 0x7ff```
  - |-
    ğŸ“š  en ğŸŸ¦  `PulseChannel`:
    **->** importa esa clase y agrega una propiedad `frequencySweep` con una nueva instancia (Â¡pasa ```javascript this``` al constructor!)
    **->** modifica **sample()** para que el <return temprano> tambiÃ©n revise ```javascript this.frequencySweep.mute```
    **->** modifica **step()** para que el mÃ©todo `updateTimer()` solo se llame si el `enabledFlag` de ğŸ§¹  PulseSweep estÃ¡ apagado
    **->** implementa este mÃ©todo:
    **halfFrame()**:
      **->** __continÃºa clockeando la envolvente como antes__
      **->** llama a ```javascript this.frequencySweep.clock()```
  - |-
    ğŸ“š  ah, cierto, en ğŸ§¹  `PulseSweep`, una cosa mÃ¡s:
    **onWrite(value)**:
      **->** __mantÃ©n el comportamiento actual__
      **->** aquÃ­ deberÃ­amos activar el `startFlag` del `frequencySweep` del canal
      (esto fuerza al divisor a recargarse en el siguiente tick)
  responses: []
