---
main:
  messages:
  - esto podrÃ­a causar algo de confusiÃ³n, asÃ­ que me adelanto
  - "en jerga de audio, \"sample\" puede tener dos significados diferentes:"
  - ğŸ“ˆ  un solo valor de amplitud en un momento dado (o sea <un nÃºmero>)
  - ğŸ”Š  un clip de sonido grabado (Â¡o sea <varios nÃºmeros>!)
  - ten en cuenta que los registros ğŸ  DMCSampleAddress y ğŸ“  DMCSampleLength se refieren al <segundo significado>!
  - (intentarÃ© decir "clip de sonido" para evitar confusiÃ³n)
  responses:
  - entendido, Â¿cÃ³mo funciona DPCM? [dpcm]

dpcm:
  messages:
  - los juegos escriben la direcciÃ³n de memoria donde se almacena el clip de sonido en ğŸ  DMCSampleAddress y la longitud en bytes en ğŸ“  DMCSampleLength
  - |-
    no exactamente, pero la direcciÃ³n y la longitud reales se pueden obtener asÃ­:
      ```javascript clipAddress = 0xc000 + dmcSampleAddress + (A * 64);
      clipLength = dmcSampleLength * 16 + 1;```
  - luego, escriben un <perÃ­odo DPCM> (que determina la frecuencia de reproducciÃ³n) y una <bandera de bucle> en ğŸ“¦  DMCControl
  - por Ãºltimo, escriben en ğŸ›ï¸  APUControl un valor con el bit 4 activado, lo que inicia la reproducciÃ³n si el canal DMC no estÃ¡ reproduciendo un clip
  responses:
  - Â¿y quÃ© pasa despuÃ©s? [then]

then:
  messages:
  - despuÃ©s todo lo maneja automÃ¡ticamente la APU
  - el canal comienza con un sample de salida en 0 y configura un divisor basado en el <perÃ­odo DPCM>
  - en cada pulso del divisor, la unidad procesa <un bit> del stream y <cambia> el sample de salida
  - |-
    ese bit determina la <variaciÃ³n>:
      **->** un 1 significa ~+2~
      **->** un 0 significa ~-2~
  - cuando termina de procesar todos los bits (el clip de sonido se ha terminado), la reproducciÃ³n se reinicia si la <bandera de bucle> estÃ¡ encendida
  responses:
  - esto suena complicado [exercise]

exercise:
  messages:
  - hay muchos matices en esto y puede ser difÃ­cil hacerlo bien ğŸ˜…
  - asÃ­ que te darÃ© una clase que maneja la decodificaciÃ³n DPCM
  - y tÃº solo tienes que integrarla en tu canal
  - |-
    ğŸ“š  en ğŸ“¦  `DMCChannel`:
    **->** importa ğŸ“„  ~/lib/apu/DPCM.js~ y agrega una propiedad `dpcm` con una nueva instancia
    **->** en `step()`, llama a ```javascript this.dpcm.update()```
  - |-
    ğŸ“š  implementa en ğŸ›ï¸  `APUControl`:
    **onWrite(value)**:
      **->** __mantÃ©n el comportamiento existente__
      **->** si `!this.enableDMC`:
        **->** llama a ```javascript this.apu.channels.dmc.dpcm.stop()```
      **->** si no, y ```javascript this.apu.channels.dmc.dpcm.remainingBytes() === 0```
        **->** llama a ```javascript this.apu.channels.dmc.dpcm.start()```
  responses: []
