main:
  messages:
  - el ğŸ“¦  Canal DMC les da a los juegos la capacidad de reproducir sus propios samples
  - Â¡esto permite crear cualquier forma de onda; Â¡no solo ondas cuadradas, ondas triangulares o ruido!
  - "tiene dos modos de operaciÃ³n:"
  - "ğŸ“¥  <Carga Directa>: los juegos cargan un sample de 7 bits directamente a la APU (alta calidad, pero consume mucha CPU)"
  - "ğŸ¤  <ModulaciÃ³n Delta>: la APU decodifica automÃ¡ticamente un stream DPCM usando la tÃ©cnica de ModulaciÃ³n Delta, donde cada sample se almacena como la diferencia (<delta>) con respecto a la anterior (baja calidad, pero mÃ¡s liviano)"
  responses:
  - (*) el nombre se ve gracioso [name]
  - carga directa suena mÃ¡s fÃ¡cil [exercise]

name:
  messages:
  - Â¿sÃ­? Â¿por quÃ©?
  - es el <Delta Modulation Channel Channel>
  - no veo nada malo en ello
  responses:
  - ...main

exercise:
  messages:
  - sÃ­, para nosotros es mÃ¡s simple de implementar
  - ğŸ“š  crea una clase `DMCChannel`, usando ğŸ“„  ~/tmpl/apu/DMCChannel.js~ como plantilla
  - |-
    ğŸ“š  en ğŸ”Š  `APU`:
    **->** importa el canal y agrega una clave `dmc` a ```javascript this.channels``` con una nueva instancia
      (Â¡nota que el constructor recibe tanto la `apu` como la `cpu`! Â¡vamos a necesitar eso luego!)
    **->** en `step()`, antes de incrementar el contador de samples, llama a ```javascript this.channels.dmc.step()```
    **->** tambiÃ©n en `step()`, agrega el canal DMC a la mezcla:
      ```javascript const dmc = this.channels.dmc.sample();
      this.sample = (pulse1 + pulse2 + triangle + noise + dmc) * 0.01;

      onSample(this.sample, pulse1, pulse2, triangle, noise, dmc);```
  - |-
      ğŸ“š  implementa en ğŸ“¥  `DMCLoad`:
      **onLoad()**:
        **->** usa ```javascript this.addField(...)``` para definir un campo `directLoad` de 7 bits desde el bit 0
      **onWrite(value)**:
        **->** asigna el valor con ```javascript this.setValue(...)```
        **->** asigna el <output sample> del canal a ```javascript this.directLoad```
  responses: []
