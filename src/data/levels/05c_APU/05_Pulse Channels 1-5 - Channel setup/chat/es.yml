---
main:
  messages:
  - el Canal Pulso 1 tiene que saber quÃ© nota debe producir, Â¿verdad?
  - bueno, el cÃ³digo del juego escribe un valor de timer de 11 bits en los registros ğŸ•¡  Pulse1TimerLow y ğŸ•›  Pulse1TimerHighLCL
  - podemos convertir valores de timer a frecuencia usando esta fÃ³rmula âš—ï¸
  - "```javascript f = fCPU / (16 * (t + 1))```"
  - "`fCPU` es la frecuencia de la CPU (~1789773~), y `t` es el valor del timer"
  responses:
  - dame un ejemplo [example]

example:
  messages:
  - segÃºn la fÃ³rmula anterior, si un juego quiere una nota de 220 Hz, el valor del timer debe ser 507
  - entonces, el juego escribirÃ­a un 251 (byte bajo de 507) en $4002 y un 1 (byte alto de 507) en $4003
  - <{Pulse1Timer.png}>
  - luego, el canal pulso de la APU oscilarÃ­a automÃ¡ticamente a 220 Hz
  responses:
  - Â¿conectamos la cosa? [exercise]

exercise:
  messages:
  - Â¡necesitamos una clase para los Canales Pulso!
  - ğŸ“š  crea una clase `PulseChannel`, usando ğŸ“„  ~/tmpl/apu/PulseChannel.js~ como plantilla
  - |-
    ğŸ“š  agrega una propiedad `channels` a ğŸ”Š  `APU`, asignada a:
      ```javascript {
        pulses: [
          new PulseChannel(this, 0, "enablePulse1"),
          new PulseChannel(this, 1, "enablePulse2")
        ],
      }```
  - ğŸ“š  llama al mÃ©todo `step()` de los dos canales pulso al inicio de ğŸ”Š `APU::step()`
  - |-
    ğŸ“š  reemplaza el <cÃ³digo de prueba> actual en ğŸ”Š  `APU::sample(...)` con algo como:
      ```javascript const pulse1 = this.channels.pulses[0].sample();
      const pulse2 = this.channels.pulses[1].sample();
      this.sample = (pulse1 + pulse2) * 0.01;```
  - |-
    ğŸ“š  reemplaza la llamada a `onSample(...)` con:
      ```javascript onSample(this.sample, pulse1, pulse2);```
  - |-
    ğŸ“š  implementa en ğŸ•¡  `PulseTimerLow`:
    **onWrite(value)**:
      **->** asigna el valor con ```javascript this.setValue(...)```
      **->** invoca a ```javascript updateTimer()``` en la instancia del canal pulso
  - |-
    ğŸ“š  implementa en ğŸ•›  `PulseTimerHighLCL`:
    **onLoad()**:
      **->** usa ```javascript this.addField(...)``` para definir un campo `timerHigh` de 3 bits desde el bit 0
    **onWrite(value)**:
      **->** asigna el valor con ```javascript this.setValue(...)```
      **->** invoca a ```javascript updateTimer()``` en la instancia del canal pulso
  - |-
    puedes acceder a la instancia de canal actual desde los registros de audio usando:
      ```javascript this.apu.channels.pulses[this.id]```
  responses: []
