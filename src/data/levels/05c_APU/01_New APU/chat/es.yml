---
main:
  messages:
  - 춰por fin vamos a agregar <audio> a nuestro emulador! 游댉
  - no es tan intuitivo como el <video>, as칤 que primero tendr칠 que explicar algunas cosas
  responses:
  - 쯖칩mo funciona? [how]

how:
  messages:
  - 游깱  el <audio> funciona definiendo ondas que coinciden directamente con lo que hacen los parlantes
  - 游꿧  cuando un parlante vibra a una frecuencia particular, crea una nota
  - 游늳  como el tiempo es una <unidad cont칤nua>, las computadoras almacenan las ondas como una secuencia de samples, que son n칰meros que definen la altura de la onda en un punto espec칤fico del tiempo
  - 游댝  en la NEEES, los samples son n칰meros en el rango ~0-15~, y al emular la APU, enviamos 44100 samples por segundo a la placa de sonido
  - a eso se lo llama frecuencia de muestreo
  responses:
  - (*) 쯖칩mo se ve una onda? [wave]
  - 쯖칩mo genera samples la APU? [samples]

wave:
  messages:
  - se ve... <peri칩dica>!
  - <{wave_square.png}>
  - esta es una onda cuadrada de m치ximo volumen, una forma de onda com칰n usada por la APU
  - el per칤odo indica el tiempo que tarda en completar una repetici칩n entera
  - "`per칤odo = 1 / frecuencia`, as칤 que per칤odos m치s bajos generan notas m치s agudas"
  - m치s amplitud significa m치s volumen
  - y como dije, estas se almacenan como una secuencia de samples
  - aqu칤 hay una onda m치s compleja
  - <{wave.png}>
  - puedes ver c칩mo se puede almacenar la forma de onda como una <secuencia de puntos>
  - 춰los samples!
  responses:
  - ...how

samples:
  messages:
  - como la CPU y la PPU, la APU funciona con ciclos 游
  - un ciclo es la unidad de tiempo m치s peque침a, correspondiente a un tick de reloj durante el cual actualiza su estado interno en un paso
  - la 游댉  APU corre <2x> m치s lento que la 游  CPU
  - as칤 que los ciclos de APU son m치s lentos (cada ciclo de APU dura, en tiempo, ~el doble~ que uno de CPU)
  - <{unit_speeds.png}>
  responses:
  - 쯖칩mo empezamos? [exercise]

exercise:
  messages:
  - 游닄  crea un archivo para el c칩digo de la APU, usando 游늯  ~/tmpl/apu/APU.js~ como plantilla
  - |-
    游닄  para llevar el seguimiento del tiempo, agrega este m칠todo:
    **step(onSample)**:
      **->** incrementa el contador de samples
      **->** si es momento de producir un nuevo sample:
        **->** resetea el contador de samples
        **->** llama a `onSample(...)` con el sample actual (```javascript this.sample```)
  - 游닄  luego, importa tu archivo desde 游늯  ~/code/index.js~
  - y agrega la correspondiente clave `APU` al objeto exportado
  responses:
  - (*) 쯖칩mo s칠 cu치ndo es hora de un nuevo sample? [time]

time:
  messages:
  - cada llamada a `step(...)` ser칤a un ciclo de APU, y la APU corre a 894887 Hz
  - para producir 44100 samples por segundo, 춰divide ambas cosas!
  - 894887 / 44100 nos da 20 ciclos de APU por sample
  - as칤 que deber칤as generar un nuevo sample cada vez que ```javascript this.sampleCounter``` llegue a 20
  responses:
  - ...exercise
