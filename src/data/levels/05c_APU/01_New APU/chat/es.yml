---
main:
  messages:
  - Â¡por fin vamos a agregar <audio> a nuestro emulador! ğŸ”Š
  - no es tan intuitivo como el <video>, asÃ­ que primero tendrÃ© que explicar algunas cosas
  responses:
  - Â¿cÃ³mo funciona? [how]
  - <<level.isCompleted || m.$exercise>> ğŸ“š  llÃ©vame a la acciÃ³n [start]

how:
  messages:
  - ğŸŒŠ  el <audio> funciona definiendo ondas que coinciden directamente con lo que hacen los parlantes
  - ğŸµ  cuando un parlante vibra a una frecuencia particular, crea una nota
  - ğŸ“ˆ  como el tiempo es una <unidad contÃ­nua>, las computadoras almacenan las ondas como una secuencia de samples, que son nÃºmeros que definen la altura de la onda en un punto especÃ­fico del tiempo
  - ğŸ”¢  en la NEEES, los samples son nÃºmeros en el rango ~0-15~, y al emular la APU, enviamos 44100 samples por segundo a la placa de sonido
  - a eso se lo llama frecuencia de muestreo
  responses:
  - (*) Â¿cÃ³mo se ve una onda? [wave]
  - Â¿cÃ³mo genera samples la APU? [samples]

wave:
  messages:
  - se ve... <periÃ³dica>!
  - <{wave_square.png}>
  - esta es una onda cuadrada de mÃ¡ximo volumen, una forma de onda comÃºn usada por la APU
  - el perÃ­odo indica el tiempo que tarda en completar una repeticiÃ³n entera
  - "`perÃ­odo = 1 / frecuencia`, asÃ­ que perÃ­odos mÃ¡s bajos generan notas mÃ¡s agudas"
  - mÃ¡s amplitud significa mÃ¡s volumen
  - y como dije, estas se almacenan como una secuencia de samples
  - aquÃ­ hay una onda mÃ¡s compleja
  - <{wave.png}>
  - puedes ver cÃ³mo se puede almacenar la forma de onda como una <secuencia de puntos>
  - Â¡los samples!
  responses:
  - ...how

samples:
  messages:
  - como la CPU y la PPU, la APU funciona con ciclos ğŸš²
  - un ciclo es la unidad de tiempo mÃ¡s pequeÃ±a, correspondiente a un tick de reloj durante el cual actualiza su estado interno en un paso
  - la ğŸ”Š  APU corre <2x> mÃ¡s lento que la ğŸ§   CPU
  - asÃ­ que los ciclos de APU son mÃ¡s lentos (cada ciclo de APU dura, en tiempo, ~el doble~ que uno de CPU)
  - <{unit_speeds.png}>
  responses:
  - Â¿cÃ³mo empezamos? [start]

start:
  run: |
    set((m) => m.$exercise = true);
  messages:
  - ğŸ“š  crea un archivo para el cÃ³digo de la APU, usando ğŸ“„  ~/tmpl/apu/APU.js~ como plantilla
  - |-
    ğŸ“š  para llevar el seguimiento del tiempo, agrega este mÃ©todo:
    **step(onSample)**:
      **->** incrementa el contador de samples
      **->** si es momento de producir un nuevo sample:
        **->** resetea el contador de samples
        **->** llama a `onSample(...)` con el sample actual (```javascript this.sample```)
  - ğŸ“š  luego, importa tu archivo desde ğŸ“„  ~/code/index.js~
  - y agrega la correspondiente clave `APU` al objeto exportado
  responses:
  - Â¿cÃ³mo sÃ© cuÃ¡ndo es hora de un nuevo sample? [time]

time:
  messages:
  - cada llamada a `step(...)` serÃ­a un ciclo de APU, y la APU corre a 894887 Hz
  - para producir 44100 samples por segundo, Â¡divide ambas cosas!
  - 894887 / 44100 nos da 20 ciclos de APU por sample
  - asÃ­ que deberÃ­as generar un nuevo sample cada vez que ```javascript this.sampleCounter``` llegue a 20
  responses: []
