---
main:
  messages:
  - anteriormente, dije que el Canal Triangular tiene dos contadores de longitud ğŸ“
  - "el otro es el contador lineal de longitud, que tiene 3 diferencias principales:"
  - |-
    ğŸ¯  permite a los juegos escribir exactamente la longitud que quieren en lugar de usar una tabla de longitudes prefijada
      (aÃºn bastante limitado, porque el campo tiene solo 7 bits, asÃ­ que la longitud mÃ¡xima es 127)
  - |-
    â›“ï¸  su valor no se carga de inmediato:
      - las escrituras a ğŸ“  LinearLengthCounter encienden un <valor de recarga>
      - las escrituras a ğŸ•›  TriangleTimerHighLCL encienden una <bandera de recarga>, lo cual hace que se cargue ese valor pendiente en el siguiente clock
  - ğŸ•’  se actualiza en quarter frames en lugar de half frames
  - el canal debe silenciarse cuando cualquiera de los dos contadores sea 0
  responses:
  - entendido [exercise]

exercise:
  messages:
  - |- 
    ğŸ“š  crea una clase ğŸ“  `LinearLengthCounter` que <extiende> de `LengthCounter` con lo siguiente:
    **constructor()**:
      **->** llama a ```javascript super()```
      **->** asigna ```javascript this.reload = 0```
      **->** asigna ```javascript this.reloadFlag = false```
    **fullReset()**:
      **->** llama a ```javascript this.reset()```
      **->** asigna ```javascript this.reload = 0```
      **->** asigna ```javascript this.reloadFlag = false```
    **clock(isEnabled, isHalted)**:
      **->** si `!isEnabled`:
        **->** llama a ```javascript this.reset()```
        **->** retorna

      **->** si la bandera de recarga estÃ¡ encendida:
        **->** asigna el valor de recarga a ```javascript this.counter```
      **->** si no:
        **->** llama a ```javascript super.clock(isEnabled, false);```
      
      **->** si `!isHalted`:
          **->** apaga la bandera de recarga
  - |-
    ğŸ“š  en ğŸ”º  `TriangleChannel`:
    **->** importa la clase ğŸ“  `LinearLengthCounter` y agrega una propiedad `linearLengthCounter` con una nueva instancia
    **->** modifica **sample()** para que el <return temprano> tambiÃ©n revise ```javascript !this.linearLengthCounter.isActive()```
    **->** implementa:
    **quarterFrame()**:
      **->** llama al mÃ©todo `clock(...)` del contador lineal de longitud
        (usa ```javascript this.isEnabled()``` como primer argumento)
        (para la bandera de detenciÃ³n, usa la misma que la del contador de longitud regular, Â¡la comparten!)
  - |-
    ğŸ“š  implementa en ğŸ“  `TriangleLengthControl`:
    **onLoad()**:
      **->** usa ```javascript this.addField(...)``` para definir un campo de 7 bits `linearCounterReload` desde el bit 1
    **onWrite(value)**:
      **->** __mantÃ©n el comportamiento existente__
      **->** asigna la nueva longitud a la propiedad `reload` del contador lineal de longitud del canal
        (el <reload value> es directamente ```javascript this.linearCounterReload```)
  - |-
    ğŸ“š  implementa en ğŸ•›  `TriangleTimerHighLCL`:
    **onWrite(value)**:
      **->** __mantÃ©n el comportamiento existente__
      **->** enciende la bandera de recarga del contador lineal de longitud del canal
  - ğŸ“š  en ğŸ›ï¸  `APUControl`, despuÃ©s de llamar a `reset()` en el contador de longitud, tambiÃ©n llama a `fullReset()` en el contador lineal de longitud si `enableTriangle` es 0
  responses: []
