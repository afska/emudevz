---
main:
  messages:
  - Â¡implementemos el ðŸ”º  Canal Triangular!
  - recuerda, primero necesitamos obtener el valor del timer
  - sus 8 bits bajos estÃ¡n en el registro ðŸ•¡  TriangleTimerLow, y sus 3 bits altos estÃ¡n en ðŸ•›  TriangleTimerHighLCL
  - <{triangle_timer.png}>
  - a partir del timer podemos derivar la frecuencia con la misma fÃ³rmula que usan los Canales Pulso
  - aunque el tono del canal triangular estÃ¡ <una octava mÃ¡s abajo>, asÃ­ que tenemos que dividir la frecuencia resultante por dos âš—ï¸
  - "```javascript frequency = 1789773 / (16 * (timer + 1)) / 2```"
  responses:
  - ah, por eso se usa para lÃ­neas de bajo ðŸŽ¸ [exercise]

exercise:
  messages:
  - Â¡exacto!
  - "yo ayudarÃ© con la generaciÃ³n real de la onda triangular, aquÃ­ estÃ¡ mi cÃ³digo de oscilador:"
  - ðŸ“„  ~/lib/apu/TriangleOscillator.js~
  - |-
    ðŸ“š  implementa en ðŸ•›  `TriangleTimerHighLCL`:
    **onLoad()**:
      **->** usa ```javascript this.addField(...)``` para definir un campo `timerHigh` de 3 bits desde el bit 0
    **onWrite(value)**:
      **->** asigna el valor con ```javascript this.setValue(...)```
  - |-
    ðŸ“š  crear una clase ðŸ”º  `TriangleChannel` con lo siguiente:
    **constructor(apu)**:
      **->** guarda el parÃ¡metro como una propiedad (```javascript this.apu```)
      **->** guarda el objeto de registros de triÃ¡ngulo en una propiedad:
        ```javascript this.registers = this.apu.registers.triangle;```
      **->** guarda una propiedad ```javascript this.oscillator``` con una nueva instancia del `TriangleOscillator` que enviÃ©
    **sample()**:
      **->** calcula el valor del timer basado en ðŸ•¡  TriangleTimerLow y el campo `timerHigh` de ðŸ•›  TriangleTimerHighLCL
        (usa `byte.buildU16(...)` para combinar ambos)
        (llamemos a esto `timer`)
      **->** si `timer` es menor a 2 o mayor a ~0x7ff~:
        **->** retorna 0, el canal se silencia aquÃ­
      **->** asigna la frecuencia del oscilador usando la fÃ³rmula:
        ```javascript this.oscillator.frequency = 1789773 / (16 * (timer + 1)) / 2;```
      **->** llama al mÃ©todo `sample()` del oscilador y retorna su valor
  - |-
    ðŸ“š  en ðŸ”Š  `APU`:
    **->** importa el canal y agrega una clave `triangle` a ```javascript this.channels``` con una nueva instancia
    **->** en `step()`, agrega el canal triangular a la mezcla:
      ```javascript const pulse1 = this.channels.pulses[0].sample();
      const pulse2 = this.channels.pulses[1].sample();
      const triangle = this.channels.triangle.sample();
      this.sample = (pulse1 + pulse2 + triangle) * 0.01;

      onSample(this.sample, pulse1, pulse2, triangle);```
  responses: []
