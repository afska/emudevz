---
main:
  messages:
  - repasemos rÃ¡pidamente el esquema de memoria de la NEEES
  - la CPU tiene 2 KiB de RAM ğŸ
  - pero las direcciones de memoria van de $0000 a $FFFF (~65535~)
  - por lo que el espacio direccionable completo es de 64 KiB
  responses:
  - si solo 2 KiB son RAM de verdad, Â¿quÃ© hay en los otros 62 KiB? ğŸ¤¨ [other62]

other62:
  messages:
  - <{memory.png}>
  - otras cosas, como espejos de RAM, E/S mapeada en memoria y la informaciÃ³n del cartucho
  - ğŸ”—  Â¡todo estÃ¡ conectado a la memoria!
  - asÃ­ es como el cÃ³digo mÃ¡quina interactÃºa con los dispositivos
  - el mapa de memoria tiene una estructura muy especÃ­fica, mira ğŸ“„  ~/docs/cpu/cpu_memory.es.md~
  responses:
  - (*) Â¿quÃ© es "E/S mapeada en memoria"? ğŸ—ºï¸ [io]
  - ğŸ‘Œ  ya veo... Â¿quÃ© necesito implementar? [exercise]

io:
  messages:
  - un esquema en el cual las direcciones de memoria estÃ¡n conectadas a dispositivos fÃ­sicos
  - por ejemplo...
  - leer $4016 leerÃ¡ los botones presionados del ğŸ®  mando
  - escribir los registros de la ğŸ–¥ï¸  PPU en $2000-$2007 modificarÃ¡ la pantalla
  - escribir los registros de la ğŸ”Š  APU en $4000-$4013 producirÃ¡ sonidos
  - leer $8000 probablemente leerÃ¡ el primer byte de PRG-ROM del ğŸ’¾  cartucho
  responses:
  - ...other62


exercise:
  messages:
  - por ahora, solo vamos a implementar el primer rango (ğŸ  WRAM)
  - ğŸ“š  crea una clase ğŸ  `CPUMemory`, usando ğŸ“„  ~/tmpl/CPUMemory.js~ como plantilla
  - ğŸ“š  su constructor deberÃ­a inicializar una propiedad `ram` (un `Uint8Array` de 2048 bytes)
  - |-
    ğŸ“š  implementa el primer `// TODO` de cada mÃ©todo:
    **read(address)**:
      **->** si `address` estÃ¡ dentro del rango $0000-$07FF, retorna el byte correspondiente de `ram`
      **->** __deja el resto del cÃ³digo como estÃ¡__
    **write(address, value)**:
      **->** si `address` estÃ¡ dentro del rango $0000-$07FF, escribe `value` al byte correspondiente de `ram` y retorna
      **->** __deja el resto del cÃ³digo como estÃ¡__
  - ğŸ“š  luego, como hiciste con ğŸ’¾  `Cartridge`, agrega la clase a ğŸ“„  ~/code/index.js~
  responses:
  - (*) Â¿cÃ³mo es eso de los bytes espejados? ğŸ“ [help]

help:
  messages:
  - manejÃ© eso por ti, ya que esa parte puede ser un poco rebuscada
  - bÃ¡sicamente, llamar a ```javascript read(0x0802)``` deberÃ­a retonar lo mismo que ```javascript read(0x0002)```
  - y llamar a ```javascript write(0x0802, value)``` deberÃ­a tener el mismo efecto que tiene ```javascript write(0x0002, value)```
  - por eso es que el rango $0800-$1FFF es un ğŸš½  espejo de $0000-$07FF
  - "aquÃ­ dejo un ejemplo con el otro rango espejo en $2008:"
  - <{memory_mirror.png}>
  responses:
  - ...exercise
