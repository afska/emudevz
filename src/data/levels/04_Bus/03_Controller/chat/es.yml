main:
  messages:
  - como ejemplo de <E/S mapeada en memoria>, Â¡vamos a implementar el mando! ğŸ®
  - documentÃ© cÃ³mo funciona
  - revisa ğŸ“„  ~/docs/controller.es.md~
  responses:
  - Â¿asÃ­ que por fin vamos a arreglar ese horrible bug del mando? [exercise]

exercise:
  messages:
  - sÃ­ ğŸ˜…
  - ğŸ“š  crea una clase ğŸ®  `Controller`, usando ğŸ“„  ~/tmpl/Controller.js~ como plantilla
  - ğŸ“š  implementa `onRead()` y `onWrite(...)` siguiendo la documentaciÃ³n
  - |-
    BrokenNEEES instanciarÃ¡ y conectarÃ¡ tus mandos asÃ­:
      ```javascript const controller1 = new Controller(1);
      const controller2 = new Controller(2);
      controller1.other = controller2;
      controller2.other = controller1;```
  - ğŸ“š  como siempre, agrega la clase a ğŸ“„  ~/code/index.js~
  - ğŸ“š  ah, y mapea las lecturas/escrituras de $4016 y las lecturas de $4017 en ğŸ  `CPUMemory`
  - |-
    por ejemplo, si la `address` es ```javascript 0x4016```, retorna:
      ```javascript this.controllers[0].onRead()```
  responses:
  - (*) Â¿por quÃ© necesito referenciar al <otro> mando? [other]
  - (*) espera, explÃ­came la plantilla ğŸ¤” [template]
  - (*) necesito ayuda para implementar `onRead(...)` [onread]
  - (*) necesito ayuda para implementar `onWrite(...)` [onwrite]

other:
  messages:
  - Â¡porque estÃ¡n conectados!
  - escribir un 1 en $4016 reinicia `cursor` en <ambos mandos>
  - y la bandera `strobe` solo existe en el mando del jugador 1
  - asÃ­ que, si eres el jugador 2, necesitas usar la bandera `strobe` del otro mando
  responses:
  - ...exercise

template:
  messages:
  - la clase propuesta ğŸ®  `Controller` configura un array `_buttons` con valores booleanos
  - esto indica si un botÃ³n estÃ¡ <presionado> o <liberado>
  - el array estÃ¡ ordenado siguiendo la secuencia descrita en el archivo de documentaciÃ³n
  - el mÃ©todo `update(...)` serÃ¡ llamado <automÃ¡ticamente> por BrokenNEEES para actualizar el estado de cada botÃ³n
  - y los juegos harÃ¡n <polling> a las direcciones $4016 y $4017 (llamadas a `onRead(...)`) para leer el estado actual
  responses:
  - Â¿cÃ³mo funciona el polling? [poll]

poll:
  messages:
  - |-
    en un juego de NEEES, un procedimiento tÃ­pico para leer las entradas es:
      **->** escribir un 1 en $4016
      **->** escribir un 0 en $4016
      **->** (leer $4016 y $4017) 8 veces
  responses:
  - ...exercise

onread:
  messages:
  - |-
    **onRead()**:
      **->** guarda el valor correcto de strobe en una constante
        (es decir, ```javascript this.strobe``` para <jugador 1> y ```javascript this.other.strobe``` para <jugador 2>)
        (llamemos a esto `strobe`)

      **->** si el cursor es >= 8, retorna 1

      **->** si `strobe`:
        **->** retorna el estado del primer botÃ³n <como nÃºmero>
          (```javascript +boolean``` lo convierte en nÃºmero)
      **else:**
        **->** determina si el botÃ³n actual estÃ¡ presionado (segÃºn ```javascript this.cursor```)
          (llamemos a esto `isPressed`)
        **->** incrementa ```javascript this.cursor```
        **->** retorna ```javascript +isPressed```
  responses:
  - ...exercise

onwrite:
  messages:
  - |-
    **onWrite(value)**:
      **->** asigna <el bit 0> de `value` (como booleano) a ```javascript this.strobe```
        (puedes usar `byte.getFlag(...)` de ğŸ“„  ~/lib/byte.js~)

      **->** si `this.strobe`:
        **->** reinicia ```javascript this.cursor``` a 0
        **->** reinicia ```javascript this.other.cursor``` a 0
  responses:
  - ...exercise

corollary:
  messages:
  - bien, integremos tu ğŸ®  Mando en el emulador
  - dame un segundo...
  run-after-messages: |
    level.startEffect("earthquake");
    setTimeout(() => {
      bus.emit("patching-end");
    }, 1000);
  events: 
  - patching-end [done]

done:
  run: |
    level.stopEffect();
    book.unlock("useController");
  messages:
  - âœ…  Â¡listo!
  - <! ğŸ®  Mando integrado.
  - ahora, el Ã­cono ğŸ®  en el emulador brillarÃ¡ âœ¨
  - y podrÃ¡s presionar <A> y <Derecha> al mismo tiempo ğŸ˜…
  responses:
  - â–¶ï¸  continuar [end]
