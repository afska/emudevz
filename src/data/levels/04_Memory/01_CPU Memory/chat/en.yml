---
main:
  messages:
  - you need to emulate a memory bus as well
  - the CPU has 2 KiB of RAM ğŸ
  - but the full addressable space is 64 KiB
  - we identify a memory location with a <memory address> (a 16-bit number)
  responses:
  - so, if only 2 KiB are actual RAM, what's in the other 62 KiB? ğŸ¤¨ [other62]

other62:
  messages:
  - other things, like RAM mirrors, memory-mapped I/O, and the cartridge data
  - the memory map has a very specific structure, see ğŸ“„  ~/docs/cpu/cpu_memory.en.md~
  run-after-messages: |
    store.dispatch.savedata.openFile("/docs/cpu/cpu_memory.en.md");
  responses:
  - (*) what's "memory-mapped I/O"? ğŸ—ºï¸ [io]
  - ğŸ‘Œ  I see... what do I need to implement? [implement]

io:
  messages:
  - a scheme in which memory addresses are connected to physical devices
  - for example...
  - reading $4016 will read the ğŸ®  controller's pressed buttons
  - writing the ğŸ–¥ï¸  PPU registers at $2000-$2007 will modify the screen
  - writing the ğŸ”Š  APU registers at $4000-$4013 will produce sounds
  - reading $8000 will probably read the first byte of <PRG-ROM> from the ğŸ’¾  cartridge
  responses:
  - ...other62

implement:
  messages:
  - for now, we'll just implement the first two ranges of the memory map
  - ğŸ“š  create a `CPUMemory` class in ğŸ“„  ~/code/CPUMemory.js~ with a constructor
  - it should assign a `ram` property (a `Uint8Array` of 2048 bytes)
  - |-
    implement these two methods:
    **read(address)**:
      __-> if <address> is in $0000-$07FF, returns the corresponding byte from <ram>
      -> if <address> is in $0800-$1FFF, returns a mirrored byte from <ram>
        (e.g. $0802 becomes $0002, $1023 becomes $0023)
      -> otherwise, returns 0__
    **write(address, value)**:
      __-> similar to *read*, but writes the <value> instead of returning__
  - then, as you did with `Cartridge`, add the class to ~/code/index.js~
  responses:
  - I need help with the mirrored bytes ğŸ“ [help]

help:
  messages:
  - calling `read(0x0802)` should return the same as `read(0x0002)`
  - and calling `write(0x0802, value)` should have the same effect as calling `write(0x0002, value)`
  - that's why the range $0800-$1FFF is called ğŸš½  <a mirror> of $0000-$07FF
  - to know which address you should read
  - you have to subtract the range start
  - then, use the ~%~ (remainder) operator with the size of the chunk we want to mirror
  - |-
    for example, let's look at the 4th range ("ğŸš½  Mirrors of $2000-$2007")
      range start => $2008
      chunk we want to mirror => $2000-$2007
      size of the chunk we want to mirror => $0008
  - |-
    then, we would do:
      ```javascript (address - 0x2008) % 0x0008```
  responses: []
