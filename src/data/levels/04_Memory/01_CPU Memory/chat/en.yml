---
main:
  messages:
  - let's quickly recap the NEEES memory scheme
  - the CPU has 2 KiB of RAM ğŸ
  - but memory addresses range from $0000 to $FFFF (~65535~)
  - so the full addressable space would be 64 KiB
  responses:
  - if only 2 KiB are actual RAM, what's in the other 62 KiB? ğŸ¤¨ [other62]

other62:
  messages:
  - other things, like RAM mirrors, memory-mapped I/O, and the cartridge data
  - ğŸ”—  everything is connected to the memory!
  - that's how the machine code interacts with the devices
  - the memory map has a very specific structure, see ğŸ“„  ~/docs/cpu/cpu_memory.en.md~
  responses:
  - (*) what's "memory-mapped I/O"? ğŸ—ºï¸ [io]
  - ğŸ‘Œ  I see... what do I need to implement? [implement]

io:
  messages:
  - a scheme in which memory addresses are connected to physical devices
  - for example...
  - reading $4016 will read the ğŸ®  controller's pressed buttons
  - writing the ğŸ–¥ï¸  PPU registers at $2000-$2007 will modify the screen
  - writing the ğŸ”Š  APU registers at $4000-$4013 will produce sounds
  - reading $8000 will probably read the first byte of PRG-ROM from the ğŸ’¾  cartridge
  responses:
  - ...other62

implement:
  messages:
  - for now, we'll just implement the first range (ğŸ  WRAM)
  - ğŸ“š  create a `CPUMemory` class, using ğŸ“„  ~/tmpl/CPUMemory.js~ as template
  - ğŸ“š  its constructor should initialize a `ram` property (a `Uint8Array` of 2048 bytes)
  - |-
    ğŸ“š  implement the first `// TODO` of each method:
    **read(address)**:
      **->** if `address` is in the $0000-$07FF range, returns the corresponding byte from `ram`
        (leave the rest of the code as it is)
    **write(address, value)**:
      **->** if `address` is in the $0000-$07FF range, writes the `value` to the corresponding byte from `ram` and returns
        (leave the rest of the code as it is)
  - ğŸ“š  then, as you did with `Cartridge`, add the class to ğŸ“„  ~/code/index.js~
  responses:
  - what about the mirrored bytes? ğŸ“ [help]

help:
  messages:
  - I handled that for you, as that part can be a bit tricky
  - basically, calling `read(0x0802)` should return the same as `read(0x0002)`
  - and calling `write(0x0802, value)` should have the same effect as calling `write(0x0002, value)`
  - that's why the range $0800-$1FFF is called ğŸš½  <a mirror> of $0000-$07FF
  - "here's an example with the other mirror range in $2008:"
  - <{memory_mirror.png}>
  responses: []
