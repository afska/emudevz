---
main:
  messages:
  - repasemos rÃ¡pidamente el esquema de memoria de la NEEES
  - la CPU tiene 2 KiB de RAM ğŸ
  - pero las direcciones de memoria van de $0000 a $FFFF (65535)
  - por lo que el espacio direccionable completo es de 64 KiB
  responses:
  - si solo 2 KiB son RAM de verdad, Â¿quÃ© hay en los otros 62 KiB? ğŸ¤¨ [other62]

other62:
  messages:
  - otras cosas, como espejos de RAM, E/S mapeada en memoria y la informaciÃ³n del cartucho
  - ğŸ”—  Â¡todo estÃ¡ conectado a la memoria!
  - asÃ­ es como el cÃ³digo mÃ¡quina interactÃºa con los dispositivos
  - el mapa de memoria tiene una estructura muy especÃ­fica, mira ğŸ“„  ~/docs/cpu/cpu_memory.es.md~
  responses:
  - (*) Â¿quÃ© es "E/S mapeada en memoria"? ğŸ—ºï¸ [io]
  - ğŸ‘Œ  ya veo... Â¿quÃ© necesito implementar? [implement]

io:
  messages:
  - un esquema en el cual las direcciones de memoria estÃ¡n conectadas a dispositivos fÃ­sicos
  - por ejemplo...
  - leer $4016 leerÃ¡ los botones presionados del ğŸ®  mando
  - escribir los registros de la ğŸ–¥ï¸  PPU en $2000-$2007 modificarÃ¡ la pantalla
  - escribir los registros de la ğŸ”Š  APU en $4000-$4013 producirÃ¡ sonidos
  - leer $8000 probablemente leerÃ¡ el primer byte de <PRG-ROM> del ğŸ’¾  cartucho
  responses:
  - ...other62

implement:
  messages:
  - por ahora, solo vamos a implementar los dos primeros rangos del mapa de memoria
  - ğŸ“š  _-_crea una clase `CPUMemory` en _--_ğŸ“„ _-_ ~/code/CPUMemory.js~ con un constructor_--_
  - _-_deberÃ­a asignar una propiedad `ram` (un `Uint8Array` de 2048 bytes)_--_
  - |-
    _-_implementa estos dos mÃ©todos:_--_
    *_-_*read(address)**:_--_
      *_-_*->** si ~address~ estÃ¡ dentro de $0000-$07FF, retorna el byte correspondiente de ~ram~_--_
      *_-_*->** si ~address~ estÃ¡ dentro de $0800-$1FFF, retorna un byte espejado de ~ram~_--_
        _-_(p. ej. $0802 se vuelve $0002, $1023 se vuelve $0023)_--_
      *_-_*->** caso contrario, retorna 0_--_
    *_-_*write(address, value)**:_--_
      *_-_*->** similar a ~read(...)~, pero escribe el <value> en lugar de retornar_--_
  - _-_luego, como hiciste con `Cartridge`, agrega la clase a _--_ğŸ“„ _-_ ~/code/index.js~_--_
  responses:
  - necesito ayuda con los bytes espejados ğŸ“ [help]

help:
  messages:
  - llamar a `read(0x0802)` deberÃ­a retonar lo mismo que `read(0x0002)`
  - y llamar a `write(0x0802, value)` deberÃ­a tener el mismo efecto que tiene `write(0x0002, value)`
  - por eso es que el rango $0800-$1FFF es ğŸš½  <un espejo> de $0000-$07FF
  - para saber quÃ© direcciÃ³n leer
  - puedes usar `byte.getMirroredAddress(...)`
  responses:
  - dame un ejemplo, por favor [example]

example:
  messages:
  - revisa la "Pista para espejos" al final del documento
  - usemos el 4to rango ("ğŸš½  Espejo de $2000-$2007") como ejemplo
  - tenemos un <mirror range> ($2008-$3FFF) apuntando a un <target range> ($2000-$2007)
  - |-
    `byte.getMirroredAddress(...)` toma 5 argumentos
      address => el parÃ¡metro de read(...) y write(...)
      mirrorRangeStart => ~0x2008~
      mirrorRangeEnd   => ~0x3fff~
      targetRangeStart => ~0x2000~
      targetRangeEnd   => ~0x2007~
  - |-
    entonces, harÃ­amos:
      ```javascript address = byte.getMirroredAddress(address, 0x2008, 0x3fff, 0x2000, 0x2007)```
  - y finalmente, procedemos como si `address` ya estuviera en el <target range> ($2000-$2007) ğŸ˜ƒ
  responses: []
